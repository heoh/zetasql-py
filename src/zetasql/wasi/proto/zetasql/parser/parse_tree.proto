//
// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

syntax = "proto2";

package zetasql;
option java_package = "com.google.zetasql.parser";
option java_multiple_files = true;

import "zetasql/parser/ast_enums.proto";
import "zetasql/public/parse_location_range.proto";
import "zetasql/public/type.proto";

// clang-format off

// AnyASTNodeProto holds one of the direct subclasses of ASTNode
message AnyASTNodeProto {
  oneof node {
    AnyASTStatementProto ast_statement_node = 1;
    AnyASTQueryExpressionProto ast_query_expression_node = 3;
    ASTSelectListProto ast_select_list_node = 6;
    ASTSelectColumnProto ast_select_column_node = 7;
    AnyASTExpressionProto ast_expression_node = 8;
    ASTAliasProto ast_alias_node = 12;
    AnyASTTableExpressionProto ast_table_expression_node = 15;
    ASTFromClauseProto ast_from_clause_node = 17;
    ASTWhereClauseProto ast_where_clause_node = 18;
    ASTGroupingItemProto ast_grouping_item_node = 25;
    ASTGroupByProto ast_group_by_node = 26;
    ASTOrderingExpressionProto ast_ordering_expression_node = 27;
    ASTOrderByProto ast_order_by_node = 28;
    ASTLimitOffsetProto ast_limit_offset_node = 29;
    ASTOnClauseProto ast_on_clause_node = 32;
    ASTAliasedQueryProto ast_aliased_query_node = 33;
    ASTWithClauseProto ast_with_clause_node = 35;
    ASTHavingProto ast_having_node = 36;
    AnyASTTypeProto ast_type_node = 37;
    ASTStructFieldProto ast_struct_field_node = 40;
    ASTSelectAsProto ast_select_as_node = 43;
    ASTRollupProto ast_rollup_node = 44;
    ASTStructConstructorArgProto ast_struct_constructor_arg_node = 47;
    ASTInListProto ast_in_list_node = 51;
    ASTCollateProto ast_collate_node = 63;
    ASTHavingModifierProto ast_having_modifier_node = 70;
    ASTNullOrderProto ast_null_order_node = 73;
    ASTOnOrUsingClauseListProto ast_on_or_using_clause_list_node = 74;
    ASTPartitionByProto ast_partition_by_node = 76;
    ASTStarExceptListProto ast_star_except_list_node = 78;
    ASTStarModifiersProto ast_star_modifiers_node = 79;
    ASTStarReplaceItemProto ast_star_replace_item_node = 80;
    ASTUnnestExpressionProto ast_unnest_expression_node = 84;
    ASTWindowClauseProto ast_window_clause_node = 85;
    ASTWindowDefinitionProto ast_window_definition_node = 86;
    ASTWindowFrameProto ast_window_frame_node = 87;
    ASTWindowFrameExprProto ast_window_frame_expr_node = 88;
    ASTWindowSpecificationProto ast_window_specification_node = 90;
    ASTWithOffsetProto ast_with_offset_node = 91;
    ASTAnySomeAllOpProto ast_any_some_all_op_node = 92;
    ASTStatementListProto ast_statement_list_node = 94;
    AnyASTTransactionModeProto ast_transaction_mode_node = 100;
    ASTTransactionModeListProto ast_transaction_mode_list_node = 103;
    ASTWithConnectionClauseProto ast_with_connection_clause_node = 122;
    ASTIntoAliasProto ast_into_alias_node = 123;
    ASTUnnestExpressionWithOptAliasAndOffsetProto ast_unnest_expression_with_opt_alias_and_offset_node = 124;
    ASTPivotExpressionProto ast_pivot_expression_node = 125;
    ASTPivotValueProto ast_pivot_value_node = 126;
    ASTPivotExpressionListProto ast_pivot_expression_list_node = 127;
    ASTPivotValueListProto ast_pivot_value_list_node = 128;
    ASTUnpivotInItemProto ast_unpivot_in_item_node = 130;
    ASTUnpivotInItemListProto ast_unpivot_in_item_list_node = 131;
    ASTUsingClauseProto ast_using_clause_node = 133;
    ASTForSystemTimeProto ast_for_system_time_node = 134;
    ASTQualifyProto ast_qualify_node = 135;
    ASTClampedBetweenModifierProto ast_clamped_between_modifier_node = 136;
    ASTFormatClauseProto ast_format_clause_node = 137;
    ASTPathExpressionListProto ast_path_expression_list_node = 138;
    ASTClusterByProto ast_cluster_by_node = 145;
    ASTNewConstructorArgProto ast_new_constructor_arg_node = 146;
    ASTOptionsListProto ast_options_list_node = 148;
    ASTOptionsEntryProto ast_options_entry_node = 149;
    ASTFunctionParameterProto ast_function_parameter_node = 151;
    ASTFunctionParametersProto ast_function_parameters_node = 152;
    ASTFunctionDeclarationProto ast_function_declaration_node = 153;
    ASTSqlFunctionBodyProto ast_sql_function_body_node = 154;
    ASTTVFArgumentProto ast_tvf_argument_node = 155;
    ASTModelClauseProto ast_model_clause_node = 158;
    ASTConnectionClauseProto ast_connection_clause_node = 159;
    ASTCloneDataSourceListProto ast_clone_data_source_list_node = 163;
    ASTTransformClauseProto ast_transform_clause_node = 169;
    ASTIndexItemListProto ast_index_item_list_node = 172;
    ASTIndexStoringExpressionListProto ast_index_storing_expression_list_node = 173;
    ASTIndexUnnestExpressionListProto ast_index_unnest_expression_list_node = 174;
    ASTWithPartitionColumnsClauseProto ast_with_partition_columns_clause_node = 180;
    ASTTypeParameterListProto ast_type_parameter_list_node = 182;
    ASTTVFSchemaProto ast_tvf_schema_node = 183;
    ASTTVFSchemaColumnProto ast_tvf_schema_column_node = 184;
    ASTTableAndColumnInfoProto ast_table_and_column_info_node = 185;
    ASTTableAndColumnInfoListProto ast_table_and_column_info_list_node = 186;
    ASTTemplatedParameterTypeProto ast_templated_parameter_type_node = 187;
    ASTAssertRowsModifiedProto ast_assert_rows_modified_node = 191;
    ASTReturningClauseProto ast_returning_clause_node = 192;
    AnyASTColumnAttributeProto ast_column_attribute_node = 194;
    ASTColumnAttributeListProto ast_column_attribute_list_node = 199;
    ASTStructColumnFieldProto ast_struct_column_field_node = 200;
    ASTGeneratedColumnInfoProto ast_generated_column_info_node = 201;
    AnyASTTableElementProto ast_table_element_node = 202;
    ASTTableElementListProto ast_table_element_list_node = 204;
    ASTColumnListProto ast_column_list_node = 205;
    ASTColumnPositionProto ast_column_position_node = 206;
    ASTInsertValuesRowProto ast_insert_values_row_node = 207;
    ASTInsertValuesRowListProto ast_insert_values_row_list_node = 208;
    ASTUpdateSetValueProto ast_update_set_value_node = 210;
    ASTUpdateItemProto ast_update_item_node = 211;
    ASTUpdateItemListProto ast_update_item_list_node = 212;
    ASTMergeActionProto ast_merge_action_node = 215;
    ASTMergeWhenClauseProto ast_merge_when_clause_node = 216;
    ASTMergeWhenClauseListProto ast_merge_when_clause_list_node = 217;
    ASTPrivilegeProto ast_privilege_node = 219;
    ASTPrivilegesProto ast_privileges_node = 220;
    ASTGranteeListProto ast_grantee_list_node = 221;
    ASTRepeatableClauseProto ast_repeatable_clause_node = 224;
    ASTFilterFieldsArgProto ast_filter_fields_arg_node = 225;
    ASTReplaceFieldsArgProto ast_replace_fields_arg_node = 227;
    ASTSampleSizeProto ast_sample_size_node = 229;
    ASTWithWeightProto ast_with_weight_node = 230;
    ASTSampleSuffixProto ast_sample_suffix_node = 231;
    AnyASTAlterActionProto ast_alter_action_node = 233;
    ASTAlterActionListProto ast_alter_action_list_node = 252;
    ASTForeignKeyActionsProto ast_foreign_key_actions_node = 254;
    ASTForeignKeyReferenceProto ast_foreign_key_reference_node = 255;
    ASTScriptProto ast_script_node = 256;
    ASTElseifClauseProto ast_elseif_clause_node = 257;
    ASTElseifClauseListProto ast_elseif_clause_list_node = 258;
    ASTWhenThenClauseProto ast_when_then_clause_node = 260;
    ASTWhenThenClauseListProto ast_when_then_clause_list_node = 261;
    ASTHintProto ast_hint_node = 263;
    ASTHintEntryProto ast_hint_entry_node = 264;
    ASTUnpivotInItemLabelProto ast_unpivot_in_item_label_node = 265;
    ASTDescriptorProto ast_descriptor_node = 266;
    AnyASTColumnSchemaProto ast_column_schema_node = 267;
    ASTDescriptorColumnProto ast_descriptor_column_node = 274;
    ASTDescriptorColumnListProto ast_descriptor_column_list_node = 275;
    ASTExceptionHandlerProto ast_exception_handler_node = 278;
    ASTExceptionHandlerListProto ast_exception_handler_list_node = 279;
    ASTIdentifierListProto ast_identifier_list_node = 281;
    ASTUntilClauseProto ast_until_clause_node = 283;
    ASTExecuteIntoClauseProto ast_execute_into_clause_node = 318;
    ASTExecuteUsingArgumentProto ast_execute_using_argument_node = 319;
    ASTExecuteUsingClauseProto ast_execute_using_clause_node = 320;
    ASTBracedConstructorFieldValueProto ast_braced_constructor_field_value_node = 330;
    ASTBracedConstructorFieldProto ast_braced_constructor_field_node = 331;
    ASTWithReportModifierProto ast_with_report_modifier_node = 334;
    ASTLocationProto ast_location_node = 337;
    ASTAuxLoadDataFromFilesOptionsListProto ast_aux_load_data_from_files_options_list_node = 341;
    ASTLabelProto ast_label_node = 343;
    ASTPrimaryKeyElementProto ast_primary_key_element_node = 344;
    ASTPrimaryKeyElementListProto ast_primary_key_element_list_node = 345;
    ASTSpannerTableOptionsProto ast_spanner_table_options_node = 346;
    ASTSpannerInterleaveClauseProto ast_spanner_interleave_clause_node = 347;
    ASTTtlClauseProto ast_ttl_clause_node = 348;
    ASTInputOutputClauseProto ast_input_output_clause_node = 355;
    AnyASTGraphLabelExpressionProto ast_graph_label_expression_node = 359;
    ASTGraphLabelFilterProto ast_graph_label_filter_node = 363;
    ASTSelectWithProto ast_select_with_node = 364;
    ASTAliasedQueryListProto ast_aliased_query_list_node = 365;
    ASTColumnWithOptionsProto ast_column_with_options_node = 366;
    ASTColumnWithOptionsListProto ast_column_with_options_list_node = 367;
    ASTGraphElementPatternFillerProto ast_graph_element_pattern_filler_node = 370;
    ASTGraphElementTableListProto ast_graph_element_table_list_node = 374;
    ASTGraphElementTableProto ast_graph_element_table_node = 375;
    ASTGraphNodeTableReferenceProto ast_graph_node_table_reference_node = 376;
    ASTAuxLoadDataPartitionsClauseProto ast_aux_load_data_partitions_clause_node = 378;
    ASTGraphElementLabelAndPropertiesListProto ast_graph_element_label_and_properties_list_node = 379;
    ASTGraphElementLabelAndPropertiesProto ast_graph_element_label_and_properties_node = 380;
    ASTGraphPropertiesProto ast_graph_properties_node = 381;
    ASTSetOperationMetadataListProto ast_set_operation_metadata_list_node = 384;
    ASTSetOperationAllOrDistinctProto ast_set_operation_all_or_distinct_node = 385;
    ASTSetOperationTypeProto ast_set_operation_type_node = 386;
    ASTSetOperationMetadataProto ast_set_operation_metadata_node = 387;
    ASTSetOperationColumnMatchModeProto ast_set_operation_column_match_mode_node = 389;
    ASTSetOperationColumnPropagationModeProto ast_set_operation_column_propagation_mode_node = 390;
    ASTGraphPatternProto ast_graph_pattern_node = 394;
    ASTCubeProto ast_cube_node = 399;
    ASTGroupingSetProto ast_grouping_set_node = 400;
    ASTGroupingSetListProto ast_grouping_set_list_node = 401;
    ASTExpressionWithOptAliasProto ast_expression_with_opt_alias_node = 402;
    ASTGroupByAllProto ast_group_by_all_node = 403;
    ASTFunctionTypeArgListProto ast_function_type_arg_list_node = 404;
    AnyASTPipeOperatorProto ast_pipe_operator_node = 408;
    ASTGraphLhsHintProto ast_graph_lhs_hint_node = 410;
    ASTGraphRhsHintProto ast_graph_rhs_hint_node = 411;
    ASTIdentityColumnInfoProto ast_identity_column_info_node = 424;
    ASTIdentityColumnStartWithProto ast_identity_column_start_with_node = 425;
    ASTIdentityColumnIncrementByProto ast_identity_column_increment_by_node = 426;
    ASTIdentityColumnMaxValueProto ast_identity_column_max_value_node = 427;
    ASTIdentityColumnMinValueProto ast_identity_column_min_value_node = 428;
    AnyASTGraphPathBaseProto ast_graph_path_base_node = 429;
    AnyASTGqlOperatorProto ast_gql_operator_node = 432;
    ASTGqlLetVariableDefinitionListProto ast_gql_let_variable_definition_list_node = 442;
    ASTGqlLetVariableDefinitionProto ast_gql_let_variable_definition_node = 443;
    ASTPipeSetItemProto ast_pipe_set_item_node = 450;
    ASTGraphPropertySpecificationProto ast_graph_property_specification_node = 455;
    ASTGraphPropertyNameAndValueProto ast_graph_property_name_and_value_node = 456;
    ASTGqlPageLimitProto ast_gql_page_limit_node = 458;
    ASTGqlPageOffsetProto ast_gql_page_offset_node = 459;
    ASTGqlPageProto ast_gql_page_node = 460;
    ASTAliasedQueryModifiersProto ast_aliased_query_modifiers_node = 463;
    ASTRecursionDepthModifierProto ast_recursion_depth_modifier_node = 465;
    ASTGroupingItemOrderProto ast_grouping_item_order_node = 466;
    ASTGraphPathModeProto ast_graph_path_mode_node = 469;
    ASTGraphPathSearchPrefixProto ast_graph_path_search_prefix_node = 471;
    ASTLockModeProto ast_lock_mode_node = 481;
    AnyASTRowPatternExpressionProto ast_row_pattern_expression_node = 485;
    AnyASTPostfixTableOperatorProto ast_postfix_table_operator_node = 488;
    AnyASTQuantifierProto ast_quantifier_node = 491;
    ASTQuantifierBoundProto ast_quantifier_bound_node = 493;
    ASTSubpipelineProto ast_subpipeline_node = 497;
    ASTAfterMatchSkipClauseProto ast_after_match_skip_clause_node = 499;
    ASTOnConflictClauseProto ast_on_conflict_clause_node = 501;
    ASTGraphDynamicLabelProto ast_graph_dynamic_label_node = 511;
    ASTGraphDynamicPropertiesProto ast_graph_dynamic_properties_node = 512;
    ASTGraphPathSearchPrefixCountProto ast_graph_path_search_prefix_count_node = 513;
    ASTChainedBaseExprProto ast_chained_base_expr_node = 522;
    ASTYieldItemListProto ast_yield_item_list_node = 525;
    ASTLimitAllProto ast_limit_all_node = 534;
    ASTLimitProto ast_limit_node = 535;
    ASTGraphDerivedPropertyProto ast_graph_derived_property_node = 544;
    ASTGraphDerivedPropertyListProto ast_graph_derived_property_list_node = 545;
  }
}

message ASTNodeProto {
  optional ParseLocationRangeProto parse_location_range = 1;
}

// Each class ASTFoo has a corresponding proto message ASTFooProto.
// If ASTFoo is abstract, it additionally has a message AnyASTFooProto.

// Superclass of all Statements.
message AnyASTStatementProto {
  oneof node {
    ASTQueryStatementProto ast_query_statement_node = 2;
    AnyASTScriptStatementProto ast_script_statement_node = 95;
    ASTHintedStatementProto ast_hinted_statement_node = 96;
    ASTExplainStatementProto ast_explain_statement_node = 97;
    ASTDescribeStatementProto ast_describe_statement_node = 98;
    ASTShowStatementProto ast_show_statement_node = 99;
    ASTBeginStatementProto ast_begin_statement_node = 104;
    ASTSetTransactionStatementProto ast_set_transaction_statement_node = 105;
    ASTCommitStatementProto ast_commit_statement_node = 106;
    ASTRollbackStatementProto ast_rollback_statement_node = 107;
    ASTStartBatchStatementProto ast_start_batch_statement_node = 108;
    ASTRunBatchStatementProto ast_run_batch_statement_node = 109;
    ASTAbortBatchStatementProto ast_abort_batch_statement_node = 110;
    AnyASTDdlStatementProto ast_ddl_statement_node = 111;
    ASTDropAllRowAccessPoliciesStatementProto ast_drop_all_row_access_policies_statement_node = 115;
    ASTRenameStatementProto ast_rename_statement_node = 119;
    ASTImportStatementProto ast_import_statement_node = 120;
    ASTModuleStatementProto ast_module_statement_node = 121;
    ASTCloneDataStatementProto ast_clone_data_statement_node = 164;
    ASTCreateDatabaseStatementProto ast_create_database_statement_node = 166;
    ASTExportDataStatementProto ast_export_data_statement_node = 176;
    ASTExportModelStatementProto ast_export_model_statement_node = 177;
    ASTCallStatementProto ast_call_statement_node = 178;
    ASTDefineTableStatementProto ast_define_table_statement_node = 179;
    ASTAnalyzeStatementProto ast_analyze_statement_node = 189;
    ASTAssertStatementProto ast_assert_statement_node = 190;
    ASTDeleteStatementProto ast_delete_statement_node = 193;
    ASTInsertStatementProto ast_insert_statement_node = 209;
    ASTUpdateStatementProto ast_update_statement_node = 213;
    ASTTruncateStatementProto ast_truncate_statement_node = 214;
    ASTMergeStatementProto ast_merge_statement_node = 218;
    ASTGrantStatementProto ast_grant_statement_node = 222;
    ASTRevokeStatementProto ast_revoke_statement_node = 223;
    ASTAlterAllRowAccessPoliciesStatementProto ast_alter_all_row_access_policies_statement_node = 253;
    ASTParameterAssignmentProto ast_parameter_assignment_node = 292;
    ASTSystemVariableAssignmentProto ast_system_variable_assignment_node = 293;
    ASTExecuteImmediateStatementProto ast_execute_immediate_statement_node = 321;
    ASTDefineMacroStatementProto ast_define_macro_statement_node = 369;
    ASTExportMetadataStatementProto ast_export_metadata_statement_node = 398;
    ASTCreateLocalityGroupStatementProto ast_create_locality_group_statement_node = 521;
    ASTRunStatementProto ast_run_statement_node = 530;
    ASTSubpipelineStatementProto ast_subpipeline_statement_node = 536;
    ASTStatementWithPipeOperatorsProto ast_statement_with_pipe_operators_node = 537;
  }
}
message ASTStatementProto {
  optional ASTNodeProto parent = 1;
}

// Represents a single query statement.
message ASTQueryStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTQueryProto query = 2;
}

// Represents a standalone subpipeline parsed as a statement.
// Also used for pipe suffixes on other statements in
// ASTStatementWithPipeOperators.
// See (broken link).
message ASTSubpipelineStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTSubpipelineProto subpipeline = 2;
}

// Superclass for all query expressions.  These are top-level syntactic
// constructs (outside individual SELECTs) making up a query.  These include
// Query itself, Select, UnionAll, etc.
message AnyASTQueryExpressionProto {
  oneof node {
    ASTQueryProto ast_query_node = 4;
    ASTSelectProto ast_select_node = 5;
    ASTSetOperationProto ast_set_operation_node = 77;
    ASTTableClauseProto ast_table_clause_node = 157;
    ASTFromQueryProto ast_from_query_node = 414;
    ASTGqlQueryProto ast_gql_query_node = 457;
    ASTAliasedQueryExpressionProto ast_aliased_query_expression_node = 475;
    ASTGqlGraphPatternQueryProto ast_gql_graph_pattern_query_node = 477;
    ASTGqlLinearOpsQueryProto ast_gql_linear_ops_query_node = 478;
  }
}
message ASTQueryExpressionProto {
  optional ASTNodeProto parent = 1;
  optional bool parenthesized = 2;
}

// This is a parenthesized query expression with an alias.
message ASTAliasedQueryExpressionProto {
  optional ASTQueryExpressionProto parent = 1;
  optional ASTQueryProto query = 2;
  optional ASTAliasProto alias = 3;
}

message ASTQueryProto {
  optional ASTQueryExpressionProto parent = 1;
  // If present, the WITH clause wrapping this query.
  optional ASTWithClauseProto with_clause = 2;
  // The query_expr can be a single Select, or a more complex structure
  // composed out of nodes like SetOperation and Query.
  optional AnyASTQueryExpressionProto query_expr = 3;
  // If present, applies to the result of <query_expr_> as appropriate.
  optional ASTOrderByProto order_by = 4;
  // If present, this applies after the result of <query_expr_> and
  // <order_by_>.
  optional ASTLimitOffsetProto limit_offset = 5;
  optional bool is_nested = 6;
  // True if this query represents the input to a pivot clause.
  optional bool is_pivot_input = 7;
  repeated AnyASTPipeOperatorProto pipe_operator_list = 8;
  // If present, applies to the <query_expr_>.
  optional ASTLockModeProto lock_mode = 9;
}

// This represents a FROM query, which has just a FROM clause and
// no other clauses.  This is enabled by FEATURE_PIPES.
message ASTFromQueryProto {
  optional ASTQueryExpressionProto parent = 1;
  optional ASTFromClauseProto from_clause = 2;
}

message ASTSubpipelineProto {
  optional ASTNodeProto parent = 1;
  repeated AnyASTPipeOperatorProto pipe_operator_list = 2;
  optional bool parenthesized = 3;
}

// This is the superclass of all ASTPipe* operators, representing one
// pipe operation in a chain.
message AnyASTPipeOperatorProto {
  oneof node {
    ASTPipeExtendProto ast_pipe_extend_node = 409;
    ASTPipeAggregateProto ast_pipe_aggregate_node = 412;
    ASTPipeSetOperationProto ast_pipe_set_operation_node = 413;
    ASTPipeJoinProto ast_pipe_join_node = 415;
    ASTPipeCallProto ast_pipe_call_node = 417;
    ASTPipeWindowProto ast_pipe_window_node = 418;
    ASTPipeWhereProto ast_pipe_where_node = 419;
    ASTPipeSelectProto ast_pipe_select_node = 420;
    ASTPipeLimitOffsetProto ast_pipe_limit_offset_node = 421;
    ASTPipeOrderByProto ast_pipe_order_by_node = 422;
    ASTPipeDistinctProto ast_pipe_distinct_node = 431;
    ASTPipeTablesampleProto ast_pipe_tablesample_node = 435;
    ASTPipeAsProto ast_pipe_as_node = 437;
    ASTPipeStaticDescribeProto ast_pipe_static_describe_node = 447;
    ASTPipeAssertProto ast_pipe_assert_node = 448;
    ASTPipeDropProto ast_pipe_drop_node = 449;
    ASTPipeSetProto ast_pipe_set_node = 451;
    ASTPipePivotProto ast_pipe_pivot_node = 467;
    ASTPipeUnpivotProto ast_pipe_unpivot_node = 468;
    ASTPipeRenameItemProto ast_pipe_rename_item_node = 482;
    ASTPipeRenameProto ast_pipe_rename_node = 483;
    ASTPipeLogProto ast_pipe_log_node = 498;
    ASTPipeIfProto ast_pipe_if_node = 502;
    ASTPipeIfCaseProto ast_pipe_if_case_node = 503;
    ASTPipeForkProto ast_pipe_fork_node = 504;
    ASTPipeExportDataProto ast_pipe_export_data_node = 505;
    ASTPipeRecursiveUnionProto ast_pipe_recursive_union_node = 506;
    ASTPipeMatchRecognizeProto ast_pipe_match_recognize_node = 508;
    ASTPipeCreateTableProto ast_pipe_create_table_node = 509;
    ASTPipeTeeProto ast_pipe_tee_node = 510;
    ASTPipeInsertProto ast_pipe_insert_node = 519;
    ASTPipeWithProto ast_pipe_with_node = 520;
    ASTPipeDescribeProto ast_pipe_describe_node = 527;
  }
}
message ASTPipeOperatorProto {
  optional ASTNodeProto parent = 1;
}

// Pipe EXTEND is represented with an ASTSelect with only the
// SELECT clause present, where the SELECT clause stores the
// EXTEND expression list.
// Using this representation rather than storing an ASTSelectList
// makes sharing resolver code easier.
message ASTPipeExtendProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTSelectProto select = 2;
}

message ASTPipeRenameItemProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTIdentifierProto old_name = 2;
  optional ASTIdentifierProto new_name = 3;
}

message ASTPipeRenameProto {
  optional ASTPipeOperatorProto parent = 1;
  repeated ASTPipeRenameItemProto rename_item_list = 2;
}

// Pipe AGGREGATE is represented with an ASTSelect with only the
// SELECT and (optionally) GROUP BY clause present, where the SELECT
// clause stores the AGGREGATE expression list.
// Using this representation rather than storing an ASTSelectList and
// ASTGroupBy makes sharing resolver code easier.
message ASTPipeAggregateProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTSelectProto select = 2;
  // If present, the WITH modifier specifying the mode of aggregation
  // (e.g., AGGREGATE WITH DIFFERENTIAL_PRIVACY).
  optional ASTSelectWithProto select_with = 3;
}

// Pipe set operations are represented differently from ASTSetOperation
// because we have the set operation and metadata always once, and then
// one or more (not two or more) input queries.
//
// The syntax looks like
//   <input_table> |> UNION ALL [modifiers] (query1), (query2), ...
// and it produces the combination of input_table plus all rhs queries.
message ASTPipeSetOperationProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTSetOperationMetadataProto metadata = 2;
  repeated AnyASTQueryExpressionProto inputs = 3;
}

// Pipe JOIN is represented with an ASTJoin, where the required lhs
// is always an ASTPipeJoinLhsPlaceholder.
message ASTPipeJoinProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTJoinProto join = 2;
}

message ASTPipeCallProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTTVFProto tvf = 2;
}

// Pipe WINDOW is represented with an ASTSelect with only the
// SELECT clause present, where the SELECT clause stores the
// WINDOW expression list.
// Using this representation rather than storing an ASTSelectList
// makes sharing resolver code easier.
message ASTPipeWindowProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTSelectProto select = 2;
}

message ASTPipeWhereProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTWhereClauseProto where = 2;
}

// Pipe SELECT is represented with an ASTSelect with only the
// SELECT clause present.
// Using this representation rather than storing an ASTSelectList
// makes sharing resolver code easier.
message ASTPipeSelectProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTSelectProto select = 2;
}

message ASTPipeLimitOffsetProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTLimitOffsetProto limit_offset = 2;
}

message ASTPipeOrderByProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTOrderByProto order_by = 2;
}

message ASTPipeDistinctProto {
  optional ASTPipeOperatorProto parent = 1;
}

message ASTPipeTablesampleProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTSampleClauseProto sample = 2;
}

message ASTPipeMatchRecognizeProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTMatchRecognizeClauseProto match_recognize = 2;
}

message ASTPipeAsProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTAliasProto alias = 2;
}

message ASTPipeDescribeProto {
  optional ASTPipeOperatorProto parent = 1;
}

message ASTPipeStaticDescribeProto {
  optional ASTPipeOperatorProto parent = 1;
}

message ASTPipeAssertProto {
  optional ASTPipeOperatorProto parent = 1;
  optional AnyASTExpressionProto condition = 2;
  repeated AnyASTExpressionProto message_list = 3;
}

message ASTPipeLogProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTHintProto hint = 2;
  optional ASTSubpipelineProto subpipeline = 3;
}

message ASTPipeDropProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTIdentifierListProto column_list = 2;
}

message ASTPipeSetItemProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto column = 2;
  optional AnyASTExpressionProto expression = 3;
}

message ASTPipeSetProto {
  optional ASTPipeOperatorProto parent = 1;
  repeated ASTPipeSetItemProto set_item_list = 2;
}

message ASTPipePivotProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTPivotClauseProto pivot_clause = 2;
}

message ASTPipeUnpivotProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTUnpivotClauseProto unpivot_clause = 2;
}

// `if_cases` must have at least one item. The first item is the IF case.
// Additional items are ELSEIF cases.
message ASTPipeIfProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTHintProto hint = 2;
  repeated ASTPipeIfCaseProto if_cases = 3;
  optional ASTSubpipelineProto else_subpipeline = 4;
}

message ASTPipeIfCaseProto {
  optional ASTPipeOperatorProto parent = 1;
  optional AnyASTExpressionProto condition = 2;
  optional ASTSubpipelineProto subpipeline = 3;
}

message ASTPipeForkProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTHintProto hint = 2;
  repeated ASTSubpipelineProto subpipeline_list = 3;
}

message ASTPipeTeeProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTHintProto hint = 2;
  repeated ASTSubpipelineProto subpipeline_list = 3;
}

message ASTPipeWithProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTWithClauseProto with_clause = 2;
}

message ASTPipeExportDataProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTExportDataStatementProto export_data_statement = 2;
}

message ASTPipeCreateTableProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTCreateTableStatementProto create_table_statement = 2;
}

message ASTPipeInsertProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTInsertStatementProto insert_statement = 2;
}

message ASTSelectProto {
  optional ASTQueryExpressionProto parent = 1;
  optional ASTHintProto hint = 2;
  optional ASTSelectWithProto select_with = 3;
  optional bool distinct = 4;
  optional ASTSelectAsProto select_as = 5;
  optional ASTSelectListProto select_list = 6;
  optional ASTFromClauseProto from_clause = 7;
  optional ASTWhereClauseProto where_clause = 8;
  optional ASTGroupByProto group_by = 9;
  optional ASTHavingProto having = 10;
  optional ASTQualifyProto qualify = 11;
  optional ASTWindowClauseProto window_clause = 12;
}

// This is the column list in SELECT, containing expressions with optional
// aliases and supporting SELECT-list features like star and dot-star.
//
// This is also used for selection lists in pipe operators, where
// ASTGroupingItemOrder suffixes may be present.
message ASTSelectListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTSelectColumnProto columns = 2;
}

message ASTSelectColumnProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  optional ASTAliasProto alias = 3;
  // This is the ordering suffix {ASC|DESC} [NULLS {FIRST|LAST}].
  // It can only be present on ASTSelectColumns parsed with the
  // `pipe_selection_item_list_with_order` rule, which is
  // currently only the pipe AGGREGATE operator.
  optional ASTGroupingItemOrderProto grouping_item_order = 4;
}

message AnyASTExpressionProto {
  oneof node {
    AnyASTLeafProto ast_leaf_node = 9;
    ASTIdentifierProto ast_identifier_node = 11;
    AnyASTGeneralizedPathExpressionProto ast_generalized_path_expression_node = 13;
    ASTAndExprProto ast_and_expr_node = 20;
    ASTBinaryExpressionProto ast_binary_expression_node = 21;
    ASTOrExprProto ast_or_expr_node = 24;
    ASTCastExpressionProto ast_cast_expression_node = 42;
    ASTFunctionCallProto ast_function_call_node = 45;
    ASTArrayConstructorProto ast_array_constructor_node = 46;
    ASTStructConstructorWithParensProto ast_struct_constructor_with_parens_node = 48;
    ASTStructConstructorWithKeywordProto ast_struct_constructor_with_keyword_node = 49;
    ASTInExpressionProto ast_in_expression_node = 50;
    ASTBetweenExpressionProto ast_between_expression_node = 52;
    ASTDateOrTimeLiteralProto ast_date_or_time_literal_node = 56;
    ASTCaseValueExpressionProto ast_case_value_expression_node = 59;
    ASTCaseNoValueExpressionProto ast_case_no_value_expression_node = 60;
    ASTBitwiseShiftExpressionProto ast_bitwise_shift_expression_node = 62;
    ASTDotStarProto ast_dot_star_node = 66;
    ASTDotStarWithModifiersProto ast_dot_star_with_modifiers_node = 67;
    ASTExpressionSubqueryProto ast_expression_subquery_node = 68;
    ASTExtractExpressionProto ast_extract_expression_node = 69;
    ASTIntervalExprProto ast_interval_expr_node = 71;
    ASTNamedArgumentProto ast_named_argument_node = 72;
    ASTStarWithModifiersProto ast_star_with_modifiers_node = 81;
    ASTUnaryExpressionProto ast_unary_expression_node = 83;
    ASTLikeExpressionProto ast_like_expression_node = 89;
    AnyASTParameterExprBaseProto ast_parameter_expr_base_node = 93;
    ASTLambdaProto ast_lambda_node = 142;
    ASTAnalyticFunctionCallProto ast_analytic_function_call_node = 143;
    ASTNewConstructorProto ast_new_constructor_node = 147;
    ASTDefaultLiteralProto ast_default_literal_node = 188;
    ASTReplaceFieldsExpressionProto ast_replace_fields_expression_node = 228;
    ASTBracedConstructorProto ast_braced_constructor_node = 332;
    ASTBracedNewConstructorProto ast_braced_new_constructor_node = 333;
    ASTWithExpressionProto ast_with_expression_node = 335;
    ASTRangeLiteralProto ast_range_literal_node = 354;
    ASTSequenceArgProto ast_sequence_arg_node = 391;
    ASTExpressionWithAliasProto ast_expression_with_alias_node = 395;
    ASTStructBracedConstructorProto ast_struct_braced_constructor_node = 462;
    ASTIntOrUnboundedProto ast_int_or_unbounded_node = 464;
    ASTGraphIsLabeledPredicateProto ast_graph_is_labeled_predicate_node = 474;
    ASTBracedConstructorLhsProto ast_braced_constructor_lhs_node = 489;
    ASTUpdateConstructorProto ast_update_constructor_node = 515;
    ASTInputTableArgumentProto ast_input_table_argument_node = 529;
    ASTConcatExprProto ast_concat_expr_node = 543;
  }
}
message ASTExpressionProto {
  optional ASTNodeProto parent = 1;
  optional bool parenthesized = 2;
}

// The name ASTLeaf is kept for backward compatibility alone. However, not
// all subclasses are necessarily leaf nodes. ASTStringLiteral and
// ASTBytesLiteral both have children which are the one or more components
// of literal concatenations. Similarly, ASTDateOrTimeLiteral and
// ASTRangeLiteral each contain a child ASTStringLiteral, which itself is not
// a leaf.
//
// The grouping does not make much sense at this point, given that it
// encompasses not only literals, but also ASTStar.
//
// Its main function was intended to be the nodes that get printed through
// image(), but this is no longer applicable. This functionality is now
// handled by a stricted abstract class ASTPrintableLeaf.
//
// This class should be removed, and subclasses should directly inherit from
// ASTExpression (just as ASTDateOrTimeLiteral does right now). Once all
// callers have been updated as such, we should remove this class from the
// hierarchy and directly inherit from ASTExpression.
message AnyASTLeafProto {
  oneof node {
    ASTStringLiteralProto ast_string_literal_node = 22;
    ASTNumericLiteralProto ast_numeric_literal_node = 53;
    ASTBigNumericLiteralProto ast_bignumeric_literal_node = 54;
    ASTBytesLiteralProto ast_bytes_literal_node = 55;
    ASTJSONLiteralProto ast_json_literal_node = 58;
    AnyASTPrintableLeafProto ast_printable_leaf_node = 452;
  }
}
message ASTLeafProto {
  optional ASTExpressionProto parent = 1;
}

// Intermediate subclass of ASTLeaf which is the parent of nodes that are
// still using image(). Ideally image() should be hidden, and only used to
// print back to the user, but it is currently being abused in some places
// to represent the value as well, such as with ASTIntLiteral and
// ASTFloatLiteral.
//
// Generally, image() should be removed, and location offsets of the node,
// leaf or not, should be enough to print back the image, for example within
// error messages.
message AnyASTPrintableLeafProto {
  oneof node {
    ASTIntLiteralProto ast_int_literal_node = 10;
    ASTBooleanLiteralProto ast_boolean_literal_node = 19;
    ASTStarProto ast_star_node = 23;
    ASTFloatLiteralProto ast_float_literal_node = 30;
    ASTNullLiteralProto ast_null_literal_node = 31;
    ASTMaxLiteralProto ast_max_literal_node = 57;
    ASTIndexAllColumnsProto ast_index_all_columns_node = 171;
    ASTMacroBodyProto ast_macro_body_node = 368;
    ASTStringLiteralComponentProto ast_string_literal_component_node = 453;
    ASTBytesLiteralComponentProto ast_bytes_literal_component_node = 454;
  }
}
message ASTPrintableLeafProto {
  optional ASTLeafProto parent = 1;
  optional string image = 2;
}

message ASTIntLiteralProto {
  optional ASTPrintableLeafProto parent = 1;
}

message ASTIdentifierProto {
  optional ASTExpressionProto parent = 1;
  optional string id_string = 2;
  // Used only by the parser to determine the correct handling of
  // "VALUE" in `SELECT AS VALUE`, as well as time functions like
  // CURRENT_TIMESTAMP() which can be called without parentheses if
  // unquoted. After parsing, this field is completely ignored.
  optional bool is_quoted = 3;
}

message ASTAliasProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto identifier = 2;
}

// Parent class that corresponds to the subset of ASTExpression nodes that are
// allowed by the <generalized_path_expression> grammar rule. It allows for some
// extra type safety vs. simply passing around ASTExpression as
// <generalized_path_expression>s.
//
// Only the following node kinds are allowed:
// - AST_PATH_EXPRESSION
// - AST_DOT_GENERALIZED_FIELD where the left hand side is a
//   <generalized_path_expression>.
// - AST_DOT_IDENTIFIER where the left hand side is a
//   <generalized_path_expression>.
// - AST_ARRAY_ELEMENT where the left hand side is a
//   <generalized_path_expression>
//
// Note that the type system does not capture the "pureness constraint" that,
// e.g., the left hand side of an AST_DOT_GENERALIZED_FIELD must be a
// <generalized_path_expression> in order for the node. However, it is still
// considered a bug to create a variable with type ASTGeneralizedPathExpression
// that does not satisfy the pureness constraint (similarly, it is considered a
// bug to call a function with an ASTGeneralizedPathExpression argument that
// does not satisfy the pureness constraint).
message AnyASTGeneralizedPathExpressionProto {
  oneof node {
    ASTPathExpressionProto ast_path_expression_node = 14;
    ASTArrayElementProto ast_array_element_node = 61;
    ASTDotGeneralizedFieldProto ast_dot_generalized_field_node = 64;
    ASTDotIdentifierProto ast_dot_identifier_node = 65;
    ASTExtendedPathExpressionProto ast_extended_path_expression_node = 514;
  }
}
message ASTGeneralizedPathExpressionProto {
  optional ASTExpressionProto parent = 1;
}

// This is used for dotted identifier paths only, not dotting into
// arbitrary expressions (see ASTDotIdentifier below).
message ASTPathExpressionProto {
  optional ASTGeneralizedPathExpressionProto parent = 1;
  repeated ASTIdentifierProto names = 2;
}

// A common superclass for all postfix table operators like TABLESAMPLE.
message AnyASTPostfixTableOperatorProto {
  oneof node {
    ASTPivotClauseProto ast_pivot_clause_node = 129;
    ASTUnpivotClauseProto ast_unpivot_clause_node = 132;
    ASTSampleClauseProto ast_sample_clause_node = 232;
    ASTMatchRecognizeClauseProto ast_match_recognize_clause_node = 484;
  }
}
message ASTPostfixTableOperatorProto {
  optional ASTNodeProto parent = 1;
}

// Superclass for all table expressions.  These are things that appear in the
// from clause and produce a stream of rows like a table.
// This includes table scans, joins and subqueries.
message AnyASTTableExpressionProto {
  oneof node {
    ASTTablePathExpressionProto ast_table_path_expression_node = 16;
    ASTJoinProto ast_join_node = 34;
    ASTParenthesizedJoinProto ast_parenthesized_join_node = 75;
    ASTTableSubqueryProto ast_table_subquery_node = 82;
    ASTTVFProto ast_tvf_node = 156;
    AnyASTTableDataSourceProto ast_table_data_source_node = 160;
    ASTGraphTableQueryProto ast_graph_table_query_node = 356;
    ASTPipeJoinLhsPlaceholderProto ast_pipe_join_lhs_placeholder_node = 416;
  }
}
message ASTTableExpressionProto {
  optional ASTNodeProto parent = 1;
  repeated AnyASTPostfixTableOperatorProto postfix_operators = 2;
}

// TablePathExpression are the TableExpressions that introduce a single scan,
// referenced by a path expression or UNNEST, and can optionally have
// aliases, hints, and WITH OFFSET.
message ASTTablePathExpressionProto {
  optional ASTTableExpressionProto parent = 1;
  // Exactly one of path_exp or unnest_expr must be non-NULL.
  optional ASTPathExpressionProto path_expr = 2;
  optional ASTUnnestExpressionProto unnest_expr = 3;
  optional ASTHintProto hint = 4;
  optional ASTAliasProto alias = 5;
  // Present if the scan had WITH OFFSET.
  optional ASTWithOffsetProto with_offset = 6;
  optional ASTForSystemTimeProto for_system_time = 9;
}

// This is a placehodler ASTTableExpression used for the lhs field in
// the ASTJoin used to represent ASTPipeJoin.
message ASTPipeJoinLhsPlaceholderProto {
  optional ASTTableExpressionProto parent = 1;
}

message ASTFromClauseProto {
  optional ASTNodeProto parent = 1;
  // A FromClause has exactly one TableExpression child.
  // If the FROM clause has commas, they will be expressed as a tree
  // of ASTJoin nodes with join_type=COMMA.
  optional AnyASTTableExpressionProto table_expression = 2;
}

message ASTWhereClauseProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
}

message ASTBooleanLiteralProto {
  optional ASTPrintableLeafProto parent = 1;
  optional bool value = 2;
}

message ASTAndExprProto {
  optional ASTExpressionProto parent = 1;
  repeated AnyASTExpressionProto conjuncts = 2;
}

message ASTBinaryExpressionProto {
  optional ASTExpressionProto parent = 1;
  // See description of Op values in ast_enums.proto.
  optional ASTBinaryExpressionEnums.Op op = 2;
  // Signifies whether the binary operator has a preceding NOT to it.
  // For NOT LIKE and IS NOT.
  optional bool is_not = 3;
  optional AnyASTExpressionProto lhs = 4;
  optional AnyASTExpressionProto rhs = 5;
}

// Represents a string literal which could be just a singleton or a whole
// concatenation.
message ASTStringLiteralProto {
  optional ASTLeafProto parent = 1;
  repeated ASTStringLiteralComponentProto components = 2;
  optional string string_value = 3;
}

message ASTStringLiteralComponentProto {
  optional ASTPrintableLeafProto parent = 1;
  optional string string_value = 2;
}

message ASTStarProto {
  optional ASTPrintableLeafProto parent = 1;
}

message ASTOrExprProto {
  optional ASTExpressionProto parent = 1;
  repeated AnyASTExpressionProto disjuncts = 2;
}

// Represents a concatenation expression, such as "a || b || c".
message ASTConcatExprProto {
  optional ASTExpressionProto parent = 1;
  repeated AnyASTExpressionProto operands = 2;
}

message ASTOrderingExpressionProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  optional ASTCollateProto collate = 3;
  optional ASTNullOrderProto null_order = 4;
  optional ASTOrderingExpressionEnums.OrderingSpec ordering_spec = 5;
  optional ASTOptionsListProto option_list = 6;
}

message ASTOrderByProto {
  optional ASTNodeProto parent = 1;
  optional ASTHintProto hint = 2;
  repeated ASTOrderingExpressionProto ordering_expressions = 3;
}

message ASTGroupingItemOrderProto {
  optional ASTNodeProto parent = 1;
  optional ASTOrderingExpressionEnums.OrderingSpec ordering_spec = 2;
  optional ASTNullOrderProto null_order = 3;
}

// Represents a grouping item, which is either an expression (a regular
// group by key), or a rollup list, or a cube list, or a grouping set list.
// The item "()", meaning an empty grouping list, is represented as an
// ASTGroupingItem with no children.
message ASTGroupingItemProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  // A rollup() containing multiple expressions.
  optional ASTRollupProto rollup = 3;
  // A cube() containing multiple expressions.
  optional ASTCubeProto cube = 4;
  // A list of grouping set and each of them is an
  // ASTGroupingSet.
  optional ASTGroupingSetListProto grouping_set_list = 5;
  // Alias can only be present for `expression` cases.
  // It can be present but is not valid outside pipe AGGREGATE.
  optional ASTAliasProto alias = 6;
  // Order can only be present for `expression` cases.
  // It can be present but is not valid outside pipe AGGREGATE.
  optional ASTGroupingItemOrderProto grouping_item_order = 7;
}

message ASTGroupByProto {
  optional ASTNodeProto parent = 1;
  optional ASTHintProto hint = 2;
  // When `all` is set, it represents syntax: GROUP BY ALL. The syntax
  // is mutually exclusive with syntax GROUP BY `grouping items`, in
  // which case `all` is nullptr and `grouping_items` is non-empty.
  optional ASTGroupByAllProto all = 3;
  repeated ASTGroupingItemProto grouping_items = 4;
  // True if query had AND ORDER BY on the GROUP BY.
  optional bool and_order_by = 5;
}

// Wrapper node for the keyword ALL in syntax GROUP BY ALL to provide parse
// location range.
message ASTGroupByAllProto {
  optional ASTNodeProto parent = 1;
}

// Wrapper node for the keyword ALL in syntax LIMIT ALL to provide parse
// location range.
message ASTLimitAllProto {
  optional ASTNodeProto parent = 1;
}

message ASTLimitProto {
  optional ASTNodeProto parent = 1;
  // When `all` is set, it represents syntax: LIMIT ALL. The syntax is
  // mutually exclusive with syntax LIMIT `expression`, in which case
  // `all` is nullptr and `expression` is non-empty.
  optional ASTLimitAllProto all = 2;
  optional AnyASTExpressionProto expression = 3;
}

message ASTLimitOffsetProto {
  optional ASTNodeProto parent = 1;
  // The LIMIT value. Never NULL. Either `all` should be set when ALL
  // is specified or `expression` should be set when an expression is
  // specified.
  optional ASTLimitProto limit = 2;
  // The OFFSET value. NULL if no OFFSET specified.
  optional AnyASTExpressionProto offset = 3;
}

message ASTFloatLiteralProto {
  optional ASTPrintableLeafProto parent = 1;
}

message ASTNullLiteralProto {
  optional ASTPrintableLeafProto parent = 1;
}

message ASTOnClauseProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
}

message ASTAliasedQueryProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto alias = 2;
  optional ASTQueryProto query = 3;
  optional ASTAliasedQueryModifiersProto modifiers = 4;
}

// Joins could introduce multiple scans and cannot have aliases.
// It can also represent a JOIN with a list of consecutive ON/USING
// clauses. Such a JOIN is only for internal use, and will never show up in
// the final parse tree.
message ASTJoinProto {
  optional ASTTableExpressionProto parent = 1;
  optional AnyASTTableExpressionProto lhs = 2;
  optional ASTHintProto hint = 3;
  optional AnyASTTableExpressionProto rhs = 4;
  optional ASTOnClauseProto on_clause = 5;
  optional ASTUsingClauseProto using_clause = 6;
  optional ASTOnOrUsingClauseListProto clause_list = 7;
  optional ASTJoinEnums.JoinType join_type = 8;
  optional ASTJoinEnums.JoinHint join_hint = 9;
  optional bool natural = 10;
  // unmatched_join_count_ and transformation_needed are for internal use for
  // handling consecutive ON/USING clauses. They are not used in the final AST.
  optional int64 unmatched_join_count = 11;
  optional bool transformation_needed = 12;
  optional bool contains_comma_join = 13;
  optional ASTLocationProto join_location = 14;
}

message ASTWithClauseProto {
  optional ASTNodeProto parent = 1;
  repeated ASTAliasedQueryProto with = 2;
  optional bool recursive = 3;
}

message ASTHavingProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
}

message AnyASTTypeProto {
  oneof node {
    ASTSimpleTypeProto ast_simple_type_node = 38;
    ASTArrayTypeProto ast_array_type_node = 39;
    ASTStructTypeProto ast_struct_type_node = 41;
    ASTRangeTypeProto ast_range_type_node = 358;
    ASTFunctionTypeProto ast_function_type_node = 405;
    ASTMapTypeProto ast_map_type_node = 470;
  }
}
message ASTTypeProto {
  optional ASTNodeProto parent = 1;
}

// TODO This takes a PathExpression and isn't really a simple type.
// Calling this NamedType or TypeName may be more appropriate.
message ASTSimpleTypeProto {
  optional ASTTypeProto parent = 1;
  optional ASTPathExpressionProto type_name = 2;
  optional ASTTypeParameterListProto type_parameters = 3;
  optional ASTCollateProto collate = 4;
}

message ASTArrayTypeProto {
  optional ASTTypeProto parent = 1;
  optional AnyASTTypeProto element_type = 2;
  optional ASTTypeParameterListProto type_parameters = 3;
  optional ASTCollateProto collate = 4;
}

message ASTStructFieldProto {
  optional ASTNodeProto parent = 1;
  // name_ will be NULL for anonymous fields like in STRUCT<int, string>.
  optional ASTIdentifierProto name = 2;
  optional AnyASTTypeProto type = 3;
}

message ASTStructTypeProto {
  optional ASTTypeProto parent = 1;
  repeated ASTStructFieldProto struct_fields = 2;
  optional ASTTypeParameterListProto type_parameters = 3;
  optional ASTCollateProto collate = 4;
}

message ASTFunctionTypeArgListProto {
  optional ASTNodeProto parent = 1;
  repeated AnyASTTypeProto args = 2;
}

message ASTFunctionTypeProto {
  optional ASTTypeProto parent = 1;
  optional ASTFunctionTypeArgListProto arg_list = 2;
  optional AnyASTTypeProto return_type = 3;
  optional ASTTypeParameterListProto type_parameters = 4;
  optional ASTCollateProto collate = 5;
}

message ASTCastExpressionProto {
  optional ASTExpressionProto parent = 1;
  optional AnyASTExpressionProto expr = 2;
  optional AnyASTTypeProto type = 3;
  optional ASTFormatClauseProto format = 4;
  optional bool is_safe_cast = 5;
}

// This represents a SELECT with an AS clause giving it an output type.
//   SELECT AS STRUCT ...
//   SELECT AS VALUE ...
//   SELECT AS <type_name> ...
// Exactly one of these is present.
message ASTSelectAsProto {
  optional ASTNodeProto parent = 1;
  optional ASTPathExpressionProto type_name = 2;
  // Set if as_mode() == kTypeName;
  optional ASTSelectAsEnums.AsMode as_mode = 3;
}

message ASTRollupProto {
  optional ASTNodeProto parent = 1;
  repeated AnyASTExpressionProto expressions = 2;
}

// Represents a cube list which contains a list of expressions.
message ASTCubeProto {
  optional ASTNodeProto parent = 1;
  repeated AnyASTExpressionProto expressions = 2;
}

// Represents a grouping set, which is either an empty grouping set "()",
// or a rollup, or a cube, or an expression.
//
// The expression can be single-level nested to represent a column list,
// e.g. (x, y), it will be represented as an ASTStructConstructorWithParens
// in this case.
message ASTGroupingSetProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  optional ASTRollupProto rollup = 3;
  optional ASTCubeProto cube = 4;
}

// Represents a list of grouping set, each grouping set is an ASTGroupingSet.
message ASTGroupingSetListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTGroupingSetProto grouping_sets = 2;
}

message ASTExpressionWithAliasProto {
  optional ASTExpressionProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  optional ASTAliasProto alias = 3;
}

message ASTFunctionCallProto {
  optional ASTExpressionProto parent = 1;
  optional ASTPathExpressionProto function = 2;
  repeated AnyASTExpressionProto arguments = 3;
  optional ASTHavingModifierProto having_modifier = 4;
  // If present, applies to the inputs of anonymized aggregate functions.
  optional ASTClampedBetweenModifierProto clamped_between_modifier = 5;
  // If present, applies to the inputs of aggregate functions.
  optional ASTOrderByProto order_by = 6;
  // If present, this applies to the inputs of aggregate functions.
  optional ASTLimitOffsetProto limit_offset = 7;
  // hint if not null.
  optional ASTHintProto hint = 8;
  // If present, modifies the input behavior of aggregate functions.
  optional ASTFunctionCallEnums.NullHandlingModifier null_handling_modifier = 10;
  optional bool distinct = 11;
  // Used by the parser to mark CURRENT_<date/time> functions to which no
  // parentheses have yet been applied.
  optional bool is_current_date_time_without_parentheses = 12;
  // If present, the report modifier applies to the result of anonymized
  // aggregate functions.
  optional ASTWithReportModifierProto with_report_modifier = 13;
  optional ASTGroupByProto group_by = 14;
  optional ASTWhereClauseProto where_expr = 15;
  optional ASTHavingProto having_expr = 16;
  // If true, this function was called with chained call syntax.
  // For example,
  //   `(base_expression).function_call(args)`
  // which is semantically similar to
  //   `function_call(base_expression, args)`
  //
  // `arguments` must have at least one element.  The first element is the
  // base expression.
  optional bool is_chained_call = 17;
}

message ASTChainedBaseExprProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expr = 2;
}

message ASTArrayConstructorProto {
  optional ASTExpressionProto parent = 1;
  // May return NULL. Occurs only if the array is constructed through
  // ARRAY<type>[...] syntax and not ARRAY[...] or [...].
  optional ASTArrayTypeProto type = 2;
  repeated AnyASTExpressionProto elements = 3;
}

message ASTStructConstructorArgProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  optional ASTAliasProto alias = 3;
}

// This node results from structs constructed with (expr, expr, ...).
// This will only occur when there are at least two expressions.
message ASTStructConstructorWithParensProto {
  optional ASTExpressionProto parent = 1;
  repeated AnyASTExpressionProto field_expressions = 2;
}

// This node results from structs constructed with the STRUCT keyword.
//   STRUCT(expr [AS alias], ...)
//   STRUCT<...>(expr [AS alias], ...)
// Both forms support empty field lists.
// The struct_type_ child will be non-NULL for the second form,
// which includes the struct's field list.
message ASTStructConstructorWithKeywordProto {
  optional ASTExpressionProto parent = 1;
  optional ASTStructTypeProto struct_type = 2;
  repeated ASTStructConstructorArgProto fields = 3;
}

message ASTInExpressionProto {
  optional ASTExpressionProto parent = 1;
  optional AnyASTExpressionProto lhs = 2;
  // Hints specified on IN clause.
  // This can be set only if IN clause has subquery as RHS.
  optional ASTHintProto hint = 3;
  // Exactly one of in_list, query or unnest_expr is present.
  optional ASTInListProto in_list = 4;
  optional ASTQueryProto query = 5;
  optional ASTUnnestExpressionProto unnest_expr = 6;
  // Signifies whether the IN operator has a preceding NOT to it.
  optional bool is_not = 7;
  // Represents the location of the 'IN' token. Used only for error
  // messages.
  optional ASTLocationProto in_location = 8;
}

// This implementation is shared with the IN operator and LIKE ANY/SOME/ALL.
message ASTInListProto {
  optional ASTNodeProto parent = 1;
  repeated AnyASTExpressionProto list = 2;
}

message ASTBetweenExpressionProto {
  optional ASTExpressionProto parent = 1;
  optional AnyASTExpressionProto lhs = 2;
  optional AnyASTExpressionProto low = 3;
  optional AnyASTExpressionProto high = 4;
  // Signifies whether the BETWEEN operator has a preceding NOT to it.
  optional bool is_not = 5;
  // Represents the location of the 'BETWEEN' token. Used only for
  // error messages.
  optional ASTLocationProto between_location = 6;
}

message ASTNumericLiteralProto {
  optional ASTLeafProto parent = 1;
  optional ASTStringLiteralProto string_literal = 2;
}

message ASTBigNumericLiteralProto {
  optional ASTLeafProto parent = 1;
  optional ASTStringLiteralProto string_literal = 2;
}

// Represents a bytes literal which could be just a singleton or a whole
// concatenation.
message ASTBytesLiteralProto {
  optional ASTLeafProto parent = 1;
  repeated ASTBytesLiteralComponentProto components = 2;
  optional string bytes_value = 3;
}

message ASTBytesLiteralComponentProto {
  optional ASTPrintableLeafProto parent = 1;
}

message ASTDateOrTimeLiteralProto {
  optional ASTExpressionProto parent = 1;
  optional ASTStringLiteralProto string_literal = 2;
  optional zetasql.TypeKind type_kind = 3;
}

// This represents the value MAX that shows up in type parameter lists.
// It will not show up as a general expression anywhere else.
message ASTMaxLiteralProto {
  optional ASTPrintableLeafProto parent = 1;
}

message ASTJSONLiteralProto {
  optional ASTLeafProto parent = 1;
  optional ASTStringLiteralProto string_literal = 2;
}

message ASTCaseValueExpressionProto {
  optional ASTExpressionProto parent = 1;
  repeated AnyASTExpressionProto arguments = 2;
}

message ASTCaseNoValueExpressionProto {
  optional ASTExpressionProto parent = 1;
  repeated AnyASTExpressionProto arguments = 2;
}

message ASTArrayElementProto {
  optional ASTGeneralizedPathExpressionProto parent = 1;
  optional AnyASTExpressionProto array = 2;
  optional AnyASTExpressionProto position = 3;
  optional ASTLocationProto open_bracket_location = 4;
}

message ASTBitwiseShiftExpressionProto {
  optional ASTExpressionProto parent = 1;
  optional AnyASTExpressionProto lhs = 2;
  optional AnyASTExpressionProto rhs = 3;
  // Signifies whether the bitwise shift is of left shift type "<<" or right
  // shift type ">>".
  optional bool is_left_shift = 4;
  optional ASTLocationProto operator_location = 5;
}

message ASTCollateProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto collation_name = 2;
}

// This is a generalized form of extracting a field from an expression.
// It uses a parenthesized path_expression instead of a single identifier
// to select the field.
message ASTDotGeneralizedFieldProto {
  optional ASTGeneralizedPathExpressionProto parent = 1;
  optional AnyASTExpressionProto expr = 2;
  optional ASTPathExpressionProto path = 3;
}

// This is used for using dot to extract a field from an arbitrary expression.
// In cases where we know the left side is always an identifier path, we
// use ASTPathExpression instead.
message ASTDotIdentifierProto {
  optional ASTGeneralizedPathExpressionProto parent = 1;
  optional AnyASTExpressionProto expr = 2;
  optional ASTIdentifierProto name = 3;
}

message ASTDotStarProto {
  optional ASTExpressionProto parent = 1;
  optional AnyASTExpressionProto expr = 2;
}

// SELECT x.* EXCEPT(...) REPLACE(...).  See (broken link).
message ASTDotStarWithModifiersProto {
  optional ASTExpressionProto parent = 1;
  optional AnyASTExpressionProto expr = 2;
  optional ASTStarModifiersProto modifiers = 3;
}

// A subquery in an expression.  (Not in the FROM clause.)
message ASTExpressionSubqueryProto {
  optional ASTExpressionProto parent = 1;
  optional ASTHintProto hint = 2;
  optional ASTQueryProto query = 3;
  // The syntactic modifier on this expression subquery.
  optional ASTExpressionSubqueryEnums.Modifier modifier = 4;
}

message ASTExtractExpressionProto {
  optional ASTExpressionProto parent = 1;
  optional AnyASTExpressionProto lhs_expr = 2;
  optional AnyASTExpressionProto rhs_expr = 3;
  optional AnyASTExpressionProto time_zone_expr = 4;
}

message ASTHavingModifierProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expr = 2;
  optional ASTHavingModifierEnums.ModifierKind modifier_kind = 3;
}

message ASTIntervalExprProto {
  optional ASTExpressionProto parent = 1;
  optional AnyASTExpressionProto interval_value = 2;
  optional ASTIdentifierProto date_part_name = 3;
  optional ASTIdentifierProto date_part_name_to = 4;
}

// This represents a clause of form "SEQUENCE <target>", where <target> is a
// sequence name.
message ASTSequenceArgProto {
  optional ASTExpressionProto parent = 1;
  optional ASTPathExpressionProto sequence_path = 2;
}

// Represents a named function call argument using syntax: name => expression.
// The resolver will match these against available argument names in the
// function signature.
message ASTNamedArgumentProto {
  optional ASTExpressionProto parent = 1;
  optional ASTIdentifierProto name = 2;
  optional AnyASTExpressionProto expr = 3;
}

// This node represents the keywords INPUT TABLE, used as a TVF argument.
message ASTInputTableArgumentProto {
  optional ASTExpressionProto parent = 1;
}

message ASTNullOrderProto {
  optional ASTNodeProto parent = 1;
  optional bool nulls_first = 2;
}

message ASTOnOrUsingClauseListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTNodeProto on_or_using_clause_list = 2;
}

message ASTParenthesizedJoinProto {
  optional ASTTableExpressionProto parent = 1;
  optional ASTJoinProto join = 2;
}

message ASTPartitionByProto {
  optional ASTNodeProto parent = 1;
  optional ASTHintProto hint = 2;
  repeated AnyASTExpressionProto partitioning_expressions = 3;
}

message ASTSetOperationProto {
  optional ASTQueryExpressionProto parent = 1;
  optional ASTSetOperationMetadataListProto metadata = 2;
  repeated AnyASTQueryExpressionProto inputs = 3;
}

// Contains the list of metadata for each set operation. Note the parser
// range of this node can span the inner SELECT clauses, if any. For example,
// for the following SQL query:
//   ```
//   SELECT 1
//   UNION ALL
//   SELECT 2
//   UNION ALL
//   SELECT 3
//   ```
// the parser range of `ASTSetOperationMetadataList` starts from the first
// "UNION ALL" to the last "UNION ALL", including the "SELECT 2" in middle.
message ASTSetOperationMetadataListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTSetOperationMetadataProto set_operation_metadata_list = 2;
}

// Wrapper node for the enum ASTSetOperation::AllOrDistinct to provide parse
// location range.
message ASTSetOperationAllOrDistinctProto {
  optional ASTNodeProto parent = 1;
  optional ASTSetOperationEnums.AllOrDistinct value = 2;
}

// Wrapper node for the enum ASTSetOperation::OperationType to provide parse
// location range.
message ASTSetOperationTypeProto {
  optional ASTNodeProto parent = 1;
  optional ASTSetOperationEnums.OperationType value = 2;
}

// Wrapper node for the enum ASTSetOperation::ColumnMatchMode to provide
// parse location range.
message ASTSetOperationColumnMatchModeProto {
  optional ASTNodeProto parent = 1;
  optional ASTSetOperationEnums.ColumnMatchMode value = 2;
}

// Wrapper node for the enum ASTSetOperation::ColumnPropagationMode to
// provide parse location range.
message ASTSetOperationColumnPropagationModeProto {
  optional ASTNodeProto parent = 1;
  optional ASTSetOperationEnums.ColumnPropagationMode value = 2;
}

message ASTSetOperationMetadataProto {
  optional ASTNodeProto parent = 1;
  optional ASTSetOperationTypeProto op_type = 2;
  optional ASTSetOperationAllOrDistinctProto all_or_distinct = 3;
  optional ASTHintProto hint = 4;
  optional ASTSetOperationColumnMatchModeProto column_match_mode = 5;
  optional ASTSetOperationColumnPropagationModeProto column_propagation_mode = 6;
  // Stores the column list for the CORRESPONDING BY clause, only
  // populated when `column_match_mode` = CORRESPONDING_BY.
  optional ASTColumnListProto corresponding_by_column_list = 7;
}

message ASTStarExceptListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTIdentifierProto identifiers = 2;
}

// SELECT * EXCEPT(...) REPLACE(...).  See (broken link).
message ASTStarModifiersProto {
  optional ASTNodeProto parent = 1;
  optional ASTStarExceptListProto except_list = 2;
  repeated ASTStarReplaceItemProto replace_items = 3;
}

message ASTStarReplaceItemProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  optional ASTIdentifierProto alias = 3;
}

// SELECT * EXCEPT(...) REPLACE(...).  See (broken link).
message ASTStarWithModifiersProto {
  optional ASTExpressionProto parent = 1;
  optional ASTStarModifiersProto modifiers = 2;
}

message ASTTableSubqueryProto {
  optional ASTTableExpressionProto parent = 1;
  optional ASTQueryProto subquery = 2;
  optional ASTAliasProto alias = 3;
  optional bool is_lateral = 4;
}

message ASTUnaryExpressionProto {
  optional ASTExpressionProto parent = 1;
  optional AnyASTExpressionProto operand = 2;
  optional ASTUnaryExpressionEnums.Op op = 3;
}

message ASTExpressionWithOptAliasProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  optional ASTAliasProto optional_alias = 3;
}

message ASTUnnestExpressionProto {
  optional ASTNodeProto parent = 1;
  // Grammar guarantees `expressions_` is not empty.
  repeated ASTExpressionWithOptAliasProto expressions = 2;
  optional ASTNamedArgumentProto array_zip_mode = 3;
}

message ASTWindowClauseProto {
  optional ASTNodeProto parent = 1;
  repeated ASTWindowDefinitionProto windows = 2;
}

message ASTWindowDefinitionProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto name = 2;
  optional ASTWindowSpecificationProto window_spec = 3;
}

message ASTWindowFrameProto {
  optional ASTNodeProto parent = 1;
  optional ASTWindowFrameExprProto start_expr = 2;
  optional ASTWindowFrameExprProto end_expr = 3;
  optional ASTWindowFrameEnums.FrameUnit frame_unit = 4;
}

message ASTWindowFrameExprProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  optional ASTWindowFrameExprEnums.BoundaryType boundary_type = 3;
}

message ASTLikeExpressionProto {
  optional ASTExpressionProto parent = 1;
  optional AnyASTExpressionProto lhs = 2;
  // The any, some, or all operation used.
  optional ASTAnySomeAllOpProto op = 3;
  // Hints specified on LIKE clause.
  // This can be set only if LIKE clause has subquery as RHS.
  optional ASTHintProto hint = 4;
  // Exactly one of in_list, query or unnest_expr is present
  optional ASTInListProto in_list = 5;
  optional ASTQueryProto query = 6;
  optional ASTUnnestExpressionProto unnest_expr = 7;
  // Signifies whether the LIKE operator has a preceding NOT to it.
  optional bool is_not = 8;
  // Location of the 'LIKE' token. Used for error messages.
  optional ASTLocationProto like_location = 9;
}

message ASTWindowSpecificationProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto base_window_name = 2;
  optional ASTPartitionByProto partition_by = 3;
  optional ASTOrderByProto order_by = 4;
  optional ASTWindowFrameProto window_frame = 5;
}

message ASTWithOffsetProto {
  optional ASTNodeProto parent = 1;
  // alias may be NULL.
  optional ASTAliasProto alias = 2;
}

message ASTAnySomeAllOpProto {
  optional ASTNodeProto parent = 1;
  optional ASTAnySomeAllOpEnums.Op op = 2;
}

message AnyASTParameterExprBaseProto {
  oneof node {
    ASTParameterExprProto ast_parameter_expr_node = 139;
    ASTSystemVariableExprProto ast_system_variable_expr_node = 140;
  }
}
message ASTParameterExprBaseProto {
  optional ASTExpressionProto parent = 1;
}

// Contains a list of statements.  Variable declarations allowed only at the
// start of the list, and only if variable_declarations_allowed() is true.
message ASTStatementListProto {
  optional ASTNodeProto parent = 1;
  repeated AnyASTStatementProto statement_list = 2;
  optional bool variable_declarations_allowed = 3;
}

message AnyASTScriptStatementProto {
  oneof node {
    ASTIfStatementProto ast_if_statement_node = 259;
    ASTCaseStatementProto ast_case_statement_node = 262;
    ASTRaiseStatementProto ast_raise_statement_node = 277;
    ASTBeginEndBlockProto ast_begin_end_block_node = 280;
    ASTVariableDeclarationProto ast_variable_declaration_node = 282;
    AnyASTBreakContinueStatementProto ast_break_continue_statement_node = 284;
    ASTReturnStatementProto ast_return_statement_node = 290;
    ASTSingleAssignmentProto ast_single_assignment_node = 291;
    ASTAssignmentFromStructProto ast_assignment_from_struct_node = 294;
    AnyASTLoopStatementProto ast_loop_statement_node = 301;
  }
}
message ASTScriptStatementProto {
  optional ASTStatementProto parent = 1;
}

// This wraps any other statement to add statement-level hints.
message ASTHintedStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTHintProto hint = 2;
  optional AnyASTStatementProto statement = 3;
}

// This wraps another statement, adding pipe operators on the end.
//
// The parser doesn't use this for ASTQueryStatement or other nodes that
// can include pipe operator suffixes themselves.
//
// This can only occur if FEATURE_STATEMENT_WITH_PIPE_OPERATORS is set.
//
// These pipe suffixes are generally not handled by the analyzer, and must
// be processed by the engine.  See (broken link).
message ASTStatementWithPipeOperatorsProto {
  optional ASTStatementProto parent = 1;
  optional AnyASTStatementProto statement = 2;
  optional ASTSubpipelineStatementProto pipe_operator_suffix = 3;
}

// Represents an EXPLAIN statement.
message ASTExplainStatementProto {
  optional ASTStatementProto parent = 1;
  optional AnyASTStatementProto statement = 2;
}

// Represents a DESCRIBE statement.
message ASTDescribeStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTIdentifierProto optional_identifier = 2;
  optional ASTPathExpressionProto name = 3;
  optional ASTPathExpressionProto optional_from_name = 4;
}

// Represents a SHOW statement.
message ASTShowStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTIdentifierProto identifier = 2;
  optional ASTPathExpressionProto optional_name = 3;
  optional ASTStringLiteralProto optional_like_string = 4;
}

// Base class transaction modifier elements.
message AnyASTTransactionModeProto {
  oneof node {
    ASTTransactionIsolationLevelProto ast_transaction_isolation_level_node = 101;
    ASTTransactionReadWriteModeProto ast_transaction_read_write_mode_node = 102;
  }
}
message ASTTransactionModeProto {
  optional ASTNodeProto parent = 1;
}

message ASTTransactionIsolationLevelProto {
  optional ASTTransactionModeProto parent = 1;
  optional ASTIdentifierProto identifier1 = 2;
  // Second identifier can be non-null only if first identifier is non-null.
  optional ASTIdentifierProto identifier2 = 3;
}

message ASTTransactionReadWriteModeProto {
  optional ASTTransactionModeProto parent = 1;
  optional ASTTransactionReadWriteModeEnums.Mode mode = 2;
}

message ASTTransactionModeListProto {
  optional ASTNodeProto parent = 1;
  repeated AnyASTTransactionModeProto elements = 2;
}

// Represents a BEGIN or START TRANSACTION statement.
message ASTBeginStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTTransactionModeListProto mode_list = 2;
}

// Represents a SET TRANSACTION statement.
message ASTSetTransactionStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTTransactionModeListProto mode_list = 2;
}

// Represents a COMMIT statement.
message ASTCommitStatementProto {
  optional ASTStatementProto parent = 1;
}

// Represents a ROLLBACK statement.
message ASTRollbackStatementProto {
  optional ASTStatementProto parent = 1;
}

message ASTStartBatchStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTIdentifierProto batch_type = 2;
}

message ASTRunBatchStatementProto {
  optional ASTStatementProto parent = 1;
}

message ASTAbortBatchStatementProto {
  optional ASTStatementProto parent = 1;
}

// Common superclass of DDL statements.
message AnyASTDdlStatementProto {
  oneof node {
    ASTDropEntityStatementProto ast_drop_entity_statement_node = 112;
    ASTDropFunctionStatementProto ast_drop_function_statement_node = 113;
    ASTDropTableFunctionStatementProto ast_drop_table_function_statement_node = 114;
    ASTDropMaterializedViewStatementProto ast_drop_materialized_view_statement_node = 116;
    ASTDropSnapshotTableStatementProto ast_drop_snapshot_table_statement_node = 117;
    AnyASTCreateStatementProto ast_create_statement_node = 150;
    ASTDropRowAccessPolicyStatementProto ast_drop_row_access_policy_statement_node = 287;
    ASTDropStatementProto ast_drop_statement_node = 289;
    AnyASTAlterStatementBaseProto ast_alter_statement_base_node = 305;
    ASTDropPrivilegeRestrictionStatementProto ast_drop_privilege_restriction_statement_node = 326;
    ASTUndropStatementProto ast_undrop_statement_node = 388;
    AnyASTDropIndexStatementProto ast_drop_index_statement_node = 407;
  }
}
message ASTDdlStatementProto {
  optional ASTStatementProto parent = 1;
}

// Generic DROP statement (broken link).
message ASTDropEntityStatementProto {
  optional ASTDdlStatementProto parent = 1;
  optional ASTIdentifierProto entity_type = 2;
  optional ASTPathExpressionProto name = 3;
  optional bool is_if_exists = 4;
}

// Represents a DROP FUNCTION statement.
message ASTDropFunctionStatementProto {
  optional ASTDdlStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTFunctionParametersProto parameters = 3;
  optional bool is_if_exists = 4;
}

// Represents a DROP TABLE FUNCTION statement.
// Note: Table functions don't support overloading so function parameters are
//       not accepted in this statement.
//       (broken link)
message ASTDropTableFunctionStatementProto {
  optional ASTDdlStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional bool is_if_exists = 3;
}

// Represents a DROP ALL ROW ACCESS POLICIES statement.
message ASTDropAllRowAccessPoliciesStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTPathExpressionProto table_name = 2;
  optional bool has_access_keyword = 3;
}

// Represents a DROP MATERIALIZED VIEW statement.
message ASTDropMaterializedViewStatementProto {
  optional ASTDdlStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional bool is_if_exists = 3;
}

// Represents a DROP SNAPSHOT TABLE statement.
message ASTDropSnapshotTableStatementProto {
  optional ASTDdlStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional bool is_if_exists = 3;
}

// Represents a DROP SEARCH|VECTOR INDEX statement. It is different from the
// regular drop index in that it has a trailing "ON PATH" clause.
message AnyASTDropIndexStatementProto {
  oneof node {
    ASTDropSearchIndexStatementProto ast_drop_search_index_statement_node = 118;
    ASTDropVectorIndexStatementProto ast_drop_vector_index_statement_node = 406;
  }
}
message ASTDropIndexStatementProto {
  optional ASTDdlStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTPathExpressionProto table_name = 3;
  optional bool is_if_exists = 4;
}

// Represents a DROP SEARCH INDEX statement.
message ASTDropSearchIndexStatementProto {
  optional ASTDropIndexStatementProto parent = 1;
}

// Represents a DROP VECTOR INDEX statement.
message ASTDropVectorIndexStatementProto {
  optional ASTDropIndexStatementProto parent = 1;
}

// Represents a RENAME statement.
message ASTRenameStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTIdentifierProto identifier = 2;
  optional ASTPathExpressionProto old_name = 3;
  optional ASTPathExpressionProto new_name = 4;
}

// Represents an IMPORT statement, which currently support MODULE or PROTO
// kind. We want this statement to be a generic import at some point.
message ASTImportStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTStringLiteralProto string_value = 3;
  optional ASTAliasProto alias = 4;
  optional ASTIntoAliasProto into_alias = 5;
  optional ASTOptionsListProto options_list = 6;
  optional ASTImportStatementEnums.ImportKind import_kind = 7;
}

message ASTModuleStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTOptionsListProto options_list = 3;
}

message ASTWithConnectionClauseProto {
  optional ASTNodeProto parent = 1;
  optional ASTConnectionClauseProto connection_clause = 2;
}

message ASTIntoAliasProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto identifier = 2;
}

// A conjunction of the unnest expression and the optional alias and offset.
message ASTUnnestExpressionWithOptAliasAndOffsetProto {
  optional ASTNodeProto parent = 1;
  optional ASTUnnestExpressionProto unnest_expression = 2;
  optional ASTAliasProto optional_alias = 3;
  optional ASTWithOffsetProto optional_with_offset = 4;
}

message ASTPivotExpressionProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  optional ASTAliasProto alias = 3;
}

message ASTPivotValueProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto value = 2;
  optional ASTAliasProto alias = 3;
}

message ASTPivotExpressionListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTPivotExpressionProto expressions = 2;
}

message ASTPivotValueListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTPivotValueProto values = 2;
}

message ASTPivotClauseProto {
  optional ASTPostfixTableOperatorProto parent = 1;
  optional ASTPivotExpressionListProto pivot_expressions = 2;
  optional AnyASTExpressionProto for_expression = 3;
  optional ASTPivotValueListProto pivot_values = 4;
  optional ASTAliasProto output_alias = 5;
}

message ASTUnpivotInItemProto {
  optional ASTNodeProto parent = 1;
  optional ASTPathExpressionListProto unpivot_columns = 2;
  optional ASTUnpivotInItemLabelProto alias = 3;
}

message ASTUnpivotInItemListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTUnpivotInItemProto in_items = 2;
}

message ASTUnpivotClauseProto {
  optional ASTPostfixTableOperatorProto parent = 1;
  optional ASTPathExpressionListProto unpivot_output_value_columns = 2;
  optional ASTPathExpressionProto unpivot_output_name_column = 3;
  optional ASTUnpivotInItemListProto unpivot_in_items = 4;
  optional ASTAliasProto output_alias = 5;
  optional ASTUnpivotClauseEnums.NullFilter null_filter = 6;
}

message ASTUsingClauseProto {
  optional ASTNodeProto parent = 1;
  repeated ASTIdentifierProto keys = 2;
}

message ASTForSystemTimeProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
}

// Represents a row pattern recognition clause, i.e., MATCH_RECOGNIZE().
message ASTMatchRecognizeClauseProto {
  optional ASTPostfixTableOperatorProto parent = 1;
  optional ASTPartitionByProto partition_by = 2;
  optional ASTOrderByProto order_by = 3;
  optional ASTSelectListProto measures = 4;
  optional ASTAfterMatchSkipClauseProto after_match_skip_clause = 5;
  optional AnyASTRowPatternExpressionProto pattern = 6;
  optional ASTSelectListProto pattern_variable_definition_list = 8;
  optional ASTAliasProto output_alias = 9;
  optional ASTOptionsListProto options_list = 10;
}

message ASTAfterMatchSkipClauseProto {
  optional ASTNodeProto parent = 1;
  optional ASTAfterMatchSkipClauseEnums.AfterMatchSkipTargetType target_type = 2;
}

// Represents a pattern expression for row pattern recognition.
message AnyASTRowPatternExpressionProto {
  oneof node {
    ASTRowPatternVariableProto ast_row_pattern_variable_node = 486;
    ASTRowPatternOperationProto ast_row_pattern_operation_node = 487;
    ASTEmptyRowPatternProto ast_empty_row_pattern_node = 490;
    ASTRowPatternQuantificationProto ast_row_pattern_quantification_node = 496;
    ASTRowPatternAnchorProto ast_row_pattern_anchor_node = 500;
  }
}
message ASTRowPatternExpressionProto {
  optional ASTNodeProto parent = 1;
  optional bool parenthesized = 2;
}

message ASTRowPatternVariableProto {
  optional ASTRowPatternExpressionProto parent = 1;
  optional ASTIdentifierProto name = 2;
}

// Represents an operation on a pattern expression. For example, it can
// be an alternation (A|B) or a concatenation (A B), or quantification.
// Note that alternation is analogous to OR, while concatenation is analogous
// to AND.
message ASTRowPatternOperationProto {
  optional ASTRowPatternExpressionProto parent = 1;
  optional ASTRowPatternOperationEnums.OperationType op_type = 2;
  repeated AnyASTRowPatternExpressionProto inputs = 3;
}

// Represents an empty pattern. Unparenthesized empty patterns can occur at
// the root of the pattern, or under alternation. Never under concatenation,
// since it has no infix operator.
//
// Parenthesized empty patterns can appear anywhere.
//
// This node's location is a point location, usually the start of the
// following token.
message ASTEmptyRowPatternProto {
  optional ASTRowPatternExpressionProto parent = 1;
}

// Represents an anchor in a row pattern, i.e., `^` or `$`.
// Just like in regular expressions, the `^` anchor adds the requirement that
// the match must be at the start of the partition, while the `$` anchor
// means the match must be at the end of the partition.
message ASTRowPatternAnchorProto {
  optional ASTRowPatternExpressionProto parent = 1;
  optional ASTRowPatternAnchorEnums.Anchor anchor = 2;
}

// Represents a quantifier, either a symbol (e.g. + or *), or a
// bounded quantifier, e.g. {1, 3}.
message AnyASTQuantifierProto {
  oneof node {
    ASTBoundedQuantifierProto ast_bounded_quantifier_node = 492;
    ASTFixedQuantifierProto ast_fixed_quantifier_node = 494;
    ASTSymbolQuantifierProto ast_symbol_quantifier_node = 495;
  }
}
message ASTQuantifierProto {
  optional ASTNodeProto parent = 1;
  optional bool is_reluctant = 2;
}

// Represents a bounded quantifier, e.g. {1, 3}. At least one bound must be
// non-null.
message ASTBoundedQuantifierProto {
  optional ASTQuantifierProto parent = 1;
  optional ASTQuantifierBoundProto lower_bound = 2;
  optional ASTQuantifierBoundProto upper_bound = 3;
}

// Represents the lower or upper bound of a quantifier. This wrapper node
// is to get around the field loader mechanism.
message ASTQuantifierBoundProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto bound = 2;
}

// Represents a fixed quantifier. Note that this cannot be represented as a
// bounded quantifier with identical ends because of positional parameters:
// i.e., {?} is not the same as {?, ?}. See b/362819300 for details.
message ASTFixedQuantifierProto {
  optional ASTQuantifierProto parent = 1;
  optional AnyASTExpressionProto bound = 2;
}

// Represents a quantifier such as '+', '?', or '*'.
message ASTSymbolQuantifierProto {
  optional ASTQuantifierProto parent = 1;
  optional ASTSymbolQuantifierEnums.Symbol symbol = 2;
}

// Represents a quantified row pattern expression, e.g. (A|B)+?
message ASTRowPatternQuantificationProto {
  optional ASTRowPatternExpressionProto parent = 1;
  // The operand of the quantification. Cannot be nullptr.
  optional AnyASTRowPatternExpressionProto operand = 2;
  // The quantifier. Cannot be nullptr.
  optional AnyASTQuantifierProto quantifier = 3;
}

message ASTQualifyProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
}

message ASTClampedBetweenModifierProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto low = 2;
  optional AnyASTExpressionProto high = 3;
}

message ASTWithReportModifierProto {
  optional ASTNodeProto parent = 1;
  optional ASTOptionsListProto options_list = 2;
}

message ASTFormatClauseProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto format = 2;
  optional AnyASTExpressionProto time_zone_expr = 3;
}

message ASTPathExpressionListProto {
  optional ASTNodeProto parent = 1;
  // Guaranteed by the parser to never be empty.
  repeated ASTPathExpressionProto path_expression_list = 2;
}

message ASTParameterExprProto {
  optional ASTParameterExprBaseProto parent = 1;
  optional ASTIdentifierProto name = 2;
  optional int64 position = 3;
}

message ASTSystemVariableExprProto {
  optional ASTParameterExprBaseProto parent = 1;
  optional ASTPathExpressionProto path = 2;
}

// Function argument is required to be expression.
message ASTLambdaProto {
  optional ASTExpressionProto parent = 1;
  optional AnyASTExpressionProto argument_list = 2;
  optional AnyASTExpressionProto body = 3;
}

message ASTAnalyticFunctionCallProto {
  optional ASTExpressionProto parent = 1;
  optional ASTFunctionCallProto function = 2;
  optional ASTWindowSpecificationProto window_spec = 3;
}

message ASTClusterByProto {
  optional ASTNodeProto parent = 1;
  repeated AnyASTExpressionProto clustering_expressions = 2;
}

// At most one of 'optional_identifier' and 'optional_path_expression' are
// set.
message ASTNewConstructorArgProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  optional ASTIdentifierProto optional_identifier = 3;
  optional ASTPathExpressionProto optional_path_expression = 4;
}

message ASTNewConstructorProto {
  optional ASTExpressionProto parent = 1;
  optional ASTSimpleTypeProto type_name = 2;
  repeated ASTNewConstructorArgProto arguments = 3;
}

message ASTBracedConstructorLhsProto {
  optional ASTExpressionProto parent = 1;
  optional AnyASTGeneralizedPathExpressionProto extended_path_expr = 2;
  optional ASTBracedConstructorLhsEnums.Operation operation = 3;
}

message ASTBracedConstructorFieldValueProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  // True if "field:value" syntax is used.
  // False if "field value" syntax is used.
  // The later is only allowed in proto instead of struct.
  optional bool colon_prefixed = 3;
}

message ASTBracedConstructorFieldProto {
  optional ASTNodeProto parent = 1;
  optional ASTBracedConstructorFieldValueProto value = 4;
  // True if this field is separated by comma from the previous one,
  // e.g.all e.g. "a:1,b:2".
  // False if separated by whitespace, e.g. "a:1 b:2".
  // The latter is only allowed in proto instead of struct.
  optional bool comma_separated = 5;
  optional ASTBracedConstructorLhsProto braced_constructor_lhs = 6;
}

message ASTBracedConstructorProto {
  optional ASTExpressionProto parent = 1;
  repeated ASTBracedConstructorFieldProto fields = 3;
}

message ASTBracedNewConstructorProto {
  optional ASTExpressionProto parent = 1;
  optional ASTSimpleTypeProto type_name = 2;
  optional ASTBracedConstructorProto braced_constructor = 3;
}

message ASTExtendedPathExpressionProto {
  optional ASTGeneralizedPathExpressionProto parent = 1;
  optional AnyASTGeneralizedPathExpressionProto parenthesized_path = 2;
  optional AnyASTGeneralizedPathExpressionProto generalized_path_expression = 3;
}

message ASTUpdateConstructorProto {
  optional ASTExpressionProto parent = 1;
  optional ASTFunctionCallProto function = 2;
  optional ASTBracedConstructorProto braced_constructor = 3;
}

message ASTStructBracedConstructorProto {
  optional ASTExpressionProto parent = 1;
  optional AnyASTTypeProto type_name = 2;
  optional ASTBracedConstructorProto braced_constructor = 3;
}

message ASTOptionsListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTOptionsEntryProto options_entries = 2;
}

message ASTOptionsEntryProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto name = 2;
  // Value may be any expression; engines can decide whether they
  // support identifiers, literals, parameters, constants, etc.
  optional AnyASTExpressionProto value = 3;
  // See description of Op values in ast_enums.proto.
  optional ASTOptionsEntryEnums.AssignmentOp assignment_op = 4;
}

// Common superclass of CREATE statements supporting the common
// modifiers:
//   CREATE [OR REPLACE] [TEMP|PUBLIC|PRIVATE] <object> [IF NOT EXISTS].
message AnyASTCreateStatementProto {
  oneof node {
    ASTCreateConstantStatementProto ast_create_constant_statement_node = 165;
    ASTCreateProcedureStatementProto ast_create_procedure_statement_node = 167;
    ASTCreateModelStatementProto ast_create_model_statement_node = 170;
    ASTCreateIndexStatementProto ast_create_index_statement_node = 175;
    ASTCreateSnapshotTableStatementProto ast_create_snapshot_table_statement_node = 181;
    ASTCreateEntityStatementProto ast_create_entity_statement_node = 276;
    ASTCreateRowAccessPolicyStatementProto ast_create_row_access_policy_statement_node = 288;
    AnyASTCreateTableStmtBaseProto ast_create_table_stmt_base_node = 295;
    AnyASTCreateViewStatementBaseProto ast_create_view_statement_base_node = 298;
    AnyASTCreateFunctionStmtBaseProto ast_create_function_stmt_base_node = 313;
    ASTCreatePrivilegeRestrictionStatementProto ast_create_privilege_restriction_statement_node = 324;
    ASTCreatePropertyGraphStatementProto ast_create_property_graph_statement_node = 373;
    ASTCreateSnapshotStatementProto ast_create_snapshot_statement_node = 430;
    AnyASTCreateSchemaStmtBaseProto ast_create_schema_stmt_base_node = 438;
    ASTCreateConnectionStatementProto ast_create_connection_statement_node = 479;
    ASTCreateSequenceStatementProto ast_create_sequence_statement_node = 532;
  }
}
message ASTCreateStatementProto {
  optional ASTDdlStatementProto parent = 1;
  optional ASTCreateStatementEnums.Scope scope = 2;
  optional bool is_or_replace = 3;
  optional bool is_if_not_exists = 4;
}

message ASTFunctionParameterProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto name = 2;
  optional AnyASTTypeProto type = 3;
  optional ASTTemplatedParameterTypeProto templated_parameter_type = 4;
  optional ASTTVFSchemaProto tvf_schema = 5;
  optional ASTAliasProto alias = 6;
  optional AnyASTExpressionProto default_value = 7;
  optional ASTFunctionParameterEnums.ProcedureParameterMode procedure_parameter_mode = 8;
  optional bool is_not_aggregate = 9;
}

message ASTFunctionParametersProto {
  optional ASTNodeProto parent = 1;
  repeated ASTFunctionParameterProto parameter_entries = 2;
}

message ASTFunctionDeclarationProto {
  optional ASTNodeProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTFunctionParametersProto parameters = 3;
}

message ASTSqlFunctionBodyProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
}

// This represents an argument to a table-valued function (TVF). ZetaSQL can
// parse the argument in one of the following ways:
//
// (1) ZetaSQL parses the argument as an expression; if any arguments are
//     table subqueries then ZetaSQL will parse them as subquery expressions
//     and the resolver may interpret them as needed later. In this case the
//     expr_ of this class is filled.
//
//     These special argument forms are also parsed as ASTExpressions,
//     but analyzed specially:
//       * ASTNamedArgument
//       * ASTLambda
//       * ASTInputTable
//     These node types (other than ASTNamedArgument) can also occur
//     as named arguments themselves, inside an ASTNamedArgument.
//
// (2) ZetaSQL parses the argument as "TABLE path"; this syntax represents a
//     table argument including all columns in the named table. In this case the
//     table_clause_ of this class is non-empty.
//
// (3) ZetaSQL parses the argument as "MODEL path"; this syntax represents a
//     model argument. In this case the model_clause_ of this class is
//     non-empty.
//
// (4) ZetaSQL parses the argument as "CONNECTION path"; this syntax
//     represents a connection argument. In this case the connection_clause_ of
//     this class is non-empty.
//
// (5) ZetaSQL parses the argument as "DESCRIPTOR"; this syntax represents a
//    descriptor on a list of columns with optional types.
message ASTTVFArgumentProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expr = 2;
  optional ASTTableClauseProto table_clause = 3;
  optional ASTModelClauseProto model_clause = 4;
  optional ASTConnectionClauseProto connection_clause = 5;
  optional ASTDescriptorProto desc = 6;
}

// This represents a call to a table-valued function (TVF). Each TVF returns an
// entire output relation instead of a single scalar value. The enclosing query
// may refer to the TVF as if it were a table subquery. The TVF may accept
// scalar arguments and/or other input relations.
message ASTTVFProto {
  optional ASTTableExpressionProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  repeated ASTTVFArgumentProto argument_entries = 3;
  optional ASTHintProto hint = 4;
  optional ASTAliasProto alias = 5;
  optional bool is_lateral = 6;
}

// This represents a clause of form "TABLE <target>", where <target> is either
// a path expression representing a table name, or <target> is a TVF call.
// It is currently only supported for relation arguments to table-valued
// functions.
message ASTTableClauseProto {
  optional ASTQueryExpressionProto parent = 1;
  optional ASTPathExpressionProto table_path = 2;
  optional ASTTVFProto tvf = 3;
  optional ASTWhereClauseProto where_clause = 4;
}

// This represents a clause of form "MODEL <target>", where <target> is a model
// name.
message ASTModelClauseProto {
  optional ASTNodeProto parent = 1;
  optional ASTPathExpressionProto model_path = 2;
}

// This represents a clause of `CONNECTION DEFAULT` or `CONNECTION <path>`.
// In the former form, the connection_path will be a default literal. In the
// latter form, the connection_path will be a path expression.
message ASTConnectionClauseProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto connection_path = 2;
}

message AnyASTTableDataSourceProto {
  oneof node {
    ASTCloneDataSourceProto ast_clone_data_source_node = 161;
    ASTCopyDataSourceProto ast_copy_data_source_node = 162;
  }
}
message ASTTableDataSourceProto {
  optional ASTTableExpressionProto parent = 1;
  optional ASTPathExpressionProto path_expr = 2;
  optional ASTForSystemTimeProto for_system_time = 3;
  optional ASTWhereClauseProto where_clause = 4;
}

message ASTCloneDataSourceProto {
  optional ASTTableDataSourceProto parent = 1;
}

message ASTCopyDataSourceProto {
  optional ASTTableDataSourceProto parent = 1;
}

message ASTCloneDataSourceListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTCloneDataSourceProto data_sources = 2;
}

message ASTCloneDataStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTPathExpressionProto target_path = 2;
  optional ASTCloneDataSourceListProto data_source_list = 3;
}

// This represents a CREATE CONNECTION statement, i.e.,
// CREATE [OR REPLACE] CONNECTION
//   [IF NOT EXISTS] <name_path> OPTIONS (name=value, ...);
message ASTCreateConnectionStatementProto {
  optional ASTCreateStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTOptionsListProto options_list = 3;
}

// This represents a CREATE CONSTANT statement, i.e.,
// CREATE [OR REPLACE] [TEMP|TEMPORARY|PUBLIC|PRIVATE] CONSTANT
//   [IF NOT EXISTS] <name_path> = <expression>;
message ASTCreateConstantStatementProto {
  optional ASTCreateStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional AnyASTExpressionProto expr = 3;
}

// This represents a CREATE DATABASE statement, i.e.,
// CREATE DATABASE <name> [OPTIONS (name=value, ...)];
message ASTCreateDatabaseStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTOptionsListProto options_list = 3;
}

message ASTCreateProcedureStatementProto {
  optional ASTCreateStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTFunctionParametersProto parameters = 3;
  optional ASTOptionsListProto options_list = 4;
  // The body of a procedure. Always consists of a single BeginEndBlock
  // including the BEGIN/END keywords and text in between.
  optional ASTScriptProto body = 5;
  optional ASTWithConnectionClauseProto with_connection_clause = 6;
  optional ASTIdentifierProto language = 7;
  optional ASTStringLiteralProto code = 8;
  optional ASTCreateStatementEnums.SqlSecurity external_security = 9;
}

// A base class to be used by statements that create schemas, including
// CREATE SCHEMA and CREATE EXTERNAL SCHEMA.
message AnyASTCreateSchemaStmtBaseProto {
  oneof node {
    ASTCreateSchemaStatementProto ast_create_schema_statement_node = 168;
    ASTCreateExternalSchemaStatementProto ast_create_external_schema_statement_node = 439;
  }
}
message ASTCreateSchemaStmtBaseProto {
  optional ASTCreateStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTOptionsListProto options_list = 3;
}

// This represents a CREATE SCHEMA statement, i.e.,
// CREATE SCHEMA <name> [OPTIONS (name=value, ...)];
message ASTCreateSchemaStatementProto {
  optional ASTCreateSchemaStmtBaseProto parent = 1;
  optional ASTCollateProto collate = 2;
}

// This represents a CREATE EXTERNAL SCHEMA statement, i.e.,
// CREATE [OR REPLACE] [TEMP|TEMPORARY|PUBLIC|PRIVATE] EXTERNAL SCHEMA [IF
// NOT EXISTS] <name> [WITH CONNECTION <connection>] OPTIONS (name=value,
// ...);
message ASTCreateExternalSchemaStatementProto {
  optional ASTCreateSchemaStmtBaseProto parent = 1;
  optional ASTWithConnectionClauseProto with_connection_clause = 2;
}

message ASTAliasedQueryListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTAliasedQueryProto aliased_query_list = 2;
}

message ASTTransformClauseProto {
  optional ASTNodeProto parent = 1;
  optional ASTSelectListProto select_list = 2;
}

// This represents a CREATE MODEL statement, i.e.,
// CREATE OR REPLACE MODEL model
// TRANSFORM(...)
// OPTIONS(...)
// AS
// <query> | (<identifier> AS (<query>) [, ...]).
//
// Note that at most one of `query` and `aliased_query_list` will be
// populated, and if so the other will be null.
message ASTCreateModelStatementProto {
  optional ASTCreateStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTTransformClauseProto transform_clause = 3;
  optional ASTOptionsListProto options_list = 4;
  optional ASTQueryProto query = 5;
  optional ASTInputOutputClauseProto input_output_clause = 6;
  optional bool is_remote = 7;
  optional ASTWithConnectionClauseProto with_connection_clause = 8;
  optional ASTAliasedQueryListProto aliased_query_list = 9;
}

// Represents 'ALL COLUMNS' index key expression.
message ASTIndexAllColumnsProto {
  optional ASTPrintableLeafProto parent = 1;
  optional ASTIndexItemListProto column_options = 2;
}

// Represents the list of expressions used to order an index.
message ASTIndexItemListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTOrderingExpressionProto ordering_expressions = 2;
}

// Represents the list of expressions being used in the STORING clause of an
// index.
message ASTIndexStoringExpressionListProto {
  optional ASTNodeProto parent = 1;
  repeated AnyASTExpressionProto expressions = 2;
}

// Represents the list of unnest expressions for create_index.
message ASTIndexUnnestExpressionListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTUnnestExpressionWithOptAliasAndOffsetProto unnest_expressions = 2;
}

// Represents a CREATE INDEX statement.
message ASTCreateIndexStatementProto {
  optional ASTCreateStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTPathExpressionProto table_name = 3;
  optional ASTAliasProto optional_table_alias = 4;
  optional ASTIndexUnnestExpressionListProto optional_index_unnest_expression_list = 5;
  optional ASTIndexItemListProto index_item_list = 6;
  optional ASTIndexStoringExpressionListProto optional_index_storing_expressions = 7;
  optional ASTPartitionByProto optional_partition_by = 8;
  optional ASTOptionsListProto options_list = 9;
  optional bool is_unique = 10;
  optional bool is_search = 11;
  optional ASTSpannerInterleaveClauseProto spanner_interleave_clause = 12;
  optional bool spanner_is_null_filtered = 13;
  optional bool is_vector = 14;
}

message ASTExportDataStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTWithConnectionClauseProto with_connection_clause = 2;
  optional ASTOptionsListProto options_list = 3;
  // `query` is always present when this node is used as an EXPORT DATA
  // statement.
  // `query` is never present when this is node is used as a
  // pipe EXPORT DATA operator.
  optional ASTQueryProto query = 4;
}

message ASTExportModelStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTPathExpressionProto model_name_path = 2;
  optional ASTWithConnectionClauseProto with_connection_clause = 3;
  optional ASTOptionsListProto options_list = 4;
}

// Generic EXPORT <object_kind> METADATA statement.
message ASTExportMetadataStatementProto {
  optional ASTStatementProto parent = 1;
  optional SchemaObjectKind schema_object_kind = 2;
  optional ASTPathExpressionProto name_path = 3;
  optional ASTWithConnectionClauseProto with_connection_clause = 4;
  optional ASTOptionsListProto options_list = 5;
}

message ASTCallStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTPathExpressionProto procedure_name = 2;
  repeated ASTTVFArgumentProto arguments = 3;
}

message ASTDefineTableStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTOptionsListProto options_list = 3;
}

message ASTCreateLocalityGroupStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTOptionsListProto options_list = 3;
}

message ASTWithPartitionColumnsClauseProto {
  optional ASTNodeProto parent = 1;
  optional ASTTableElementListProto table_element_list = 2;
}

// Represents a generic CREATE SNAPSHOT statement.
// Currently used for CREATE SNAPSHOT SCHEMA statement.
message ASTCreateSnapshotStatementProto {
  optional ASTCreateStatementProto parent = 1;
  optional SchemaObjectKind schema_object_kind = 2;
  optional ASTPathExpressionProto name = 3;
  optional ASTCloneDataSourceProto clone_data_source = 4;
  optional ASTOptionsListProto options_list = 5;
}

// Represents a CREATE SNAPSHOT TABLE statement.
message ASTCreateSnapshotTableStatementProto {
  optional ASTCreateStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTCloneDataSourceProto clone_data_source = 3;
  optional ASTOptionsListProto options_list = 4;
}

message ASTTypeParameterListProto {
  optional ASTNodeProto parent = 1;
  repeated AnyASTLeafProto parameters = 2;
}

// This represents a relation argument or return type for a table-valued
// function (TVF). The resolver can convert each ASTTVFSchema directly into a
// TVFRelation object suitable for use in TVF signatures. For more information
// about the TVFRelation object, please refer to public/table_valued_function.h.
// TODO: Change the names of these objects to make them generic and
// re-usable wherever we want to represent the schema of some intermediate or
// final table. Same for ASTTVFSchemaColumn.
message ASTTVFSchemaProto {
  optional ASTNodeProto parent = 1;
  repeated ASTTVFSchemaColumnProto columns = 2;
}

// This represents one column of a relation argument or return value for a
// table-valued function (TVF). It contains the name and type of the column.
message ASTTVFSchemaColumnProto {
  optional ASTNodeProto parent = 1;
  // name_ will be NULL for value tables.
  optional ASTIdentifierProto name = 2;
  optional AnyASTTypeProto type = 3;
}

message ASTTableAndColumnInfoProto {
  optional ASTNodeProto parent = 1;
  optional ASTPathExpressionProto table_name = 2;
  optional ASTColumnListProto column_list = 3;
}

message ASTTableAndColumnInfoListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTTableAndColumnInfoProto table_and_column_info_entries = 2;
}

message ASTTemplatedParameterTypeProto {
  optional ASTNodeProto parent = 1;
  optional ASTTemplatedParameterTypeEnums.TemplatedTypeKind kind = 2;
}

// This represents the value DEFAULT in DML statements or connection clauses.
// It will not show up as a general expression anywhere else.
message ASTDefaultLiteralProto {
  optional ASTExpressionProto parent = 1;
}

message ASTAnalyzeStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTOptionsListProto options_list = 2;
  optional ASTTableAndColumnInfoListProto table_and_column_info_list = 3;
}

message ASTAssertStatementProto {
  optional ASTStatementProto parent = 1;
  optional AnyASTExpressionProto expr = 2;
  optional ASTStringLiteralProto description = 3;
}

message ASTAssertRowsModifiedProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto num_rows = 2;
}

// This represents the {THEN RETURN} clause.
// (broken link)
message ASTReturningClauseProto {
  optional ASTNodeProto parent = 1;
  optional ASTSelectListProto select_list = 2;
  optional ASTAliasProto action_alias = 3;
}

// This is used in INSERT statements to specify an alternate action if the
// the insert row causes unique constraint violations.
//
// conflict_action is either UPDATE or NOTHING
//
// conflict_target, unique_constraint_name:
// They are applicable for both conflict actions. They are optional but are
// mutually exclusive. It is allowed for both fields to be null. They will
// then be analyzed according to the conflict action.
//
// update_item_list, update_where_clause applies:
// They are applicable for conflict action UPDATE only.
message ASTOnConflictClauseProto {
  optional ASTNodeProto parent = 1;
  optional ASTOnConflictClauseEnums.ConflictAction conflict_action = 2;
  // If defined, the column list must not be empty.
  optional ASTColumnListProto conflict_target = 3;
  optional ASTIdentifierProto unique_constraint_name = 4;
  // Defined only for conflict action UPDATE. It must be non empty
  // if defined.
  optional ASTUpdateItemListProto update_item_list = 5;
  // Defined only for conflict action UPDATE. It is an optional field.
  optional AnyASTExpressionProto update_where_clause = 6;
}

// This is used for both top-level DELETE statements and for nested DELETEs
// inside ASTUpdateItem. When used at the top-level, the target is always a
// path expression.
message ASTDeleteStatementProto {
  optional ASTStatementProto parent = 1;
  optional AnyASTGeneralizedPathExpressionProto target_path = 2;
  optional ASTAliasProto alias = 3;
  optional ASTWithOffsetProto offset = 4;
  optional AnyASTExpressionProto where = 5;
  optional ASTAssertRowsModifiedProto assert_rows_modified = 6;
  optional ASTReturningClauseProto returning = 7;
  optional ASTHintProto hint = 8;
}

message AnyASTColumnAttributeProto {
  oneof node {
    ASTNotNullColumnAttributeProto ast_not_null_column_attribute_node = 195;
    ASTHiddenColumnAttributeProto ast_hidden_column_attribute_node = 196;
    ASTPrimaryKeyColumnAttributeProto ast_primary_key_column_attribute_node = 197;
    ASTForeignKeyColumnAttributeProto ast_foreign_key_column_attribute_node = 198;
  }
}
message ASTColumnAttributeProto {
  optional ASTNodeProto parent = 1;
}

message ASTNotNullColumnAttributeProto {
  optional ASTColumnAttributeProto parent = 1;
}

message ASTHiddenColumnAttributeProto {
  optional ASTColumnAttributeProto parent = 1;
}

message ASTPrimaryKeyColumnAttributeProto {
  optional ASTColumnAttributeProto parent = 1;
  optional bool enforced = 2;
}

message ASTForeignKeyColumnAttributeProto {
  optional ASTColumnAttributeProto parent = 1;
  optional ASTIdentifierProto constraint_name = 2;
  optional ASTForeignKeyReferenceProto reference = 3;
}

message ASTColumnAttributeListProto {
  optional ASTNodeProto parent = 1;
  repeated AnyASTColumnAttributeProto values = 2;
}

message ASTStructColumnFieldProto {
  optional ASTNodeProto parent = 1;
  // name_ will be NULL for anonymous fields like in STRUCT<int, string>.
  optional ASTIdentifierProto name = 2;
  optional AnyASTColumnSchemaProto schema = 3;
}

message ASTGeneratedColumnInfoProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  optional ASTGeneratedColumnInfoEnums.StoredMode stored_mode = 3;
  optional ASTGeneratedColumnInfoEnums.GeneratedMode generated_mode = 4;
  optional ASTIdentityColumnInfoProto identity_column_info = 5;
}

// Base class for CREATE TABLE elements, including column definitions and
// table constraints.
message AnyASTTableElementProto {
  oneof node {
    ASTColumnDefinitionProto ast_column_definition_node = 203;
    AnyASTTableConstraintProto ast_table_constraint_node = 270;
  }
}
message ASTTableElementProto {
  optional ASTNodeProto parent = 1;
}

message ASTColumnDefinitionProto {
  optional ASTTableElementProto parent = 1;
  optional ASTIdentifierProto name = 2;
  optional AnyASTColumnSchemaProto schema = 3;
}

message ASTTableElementListProto {
  optional ASTNodeProto parent = 1;
  repeated AnyASTTableElementProto elements = 2;
}

message ASTColumnListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTIdentifierProto identifiers = 2;
}

message ASTColumnPositionProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto identifier = 2;
  optional ASTColumnPositionEnums.RelativePositionType type = 3;
}

message ASTInsertValuesRowProto {
  optional ASTNodeProto parent = 1;
  // A row of values in a VALUES clause.  May include ASTDefaultLiteral.
  repeated AnyASTExpressionProto values = 2;
}

message ASTInsertValuesRowListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTInsertValuesRowProto rows = 2;
}

// This is used for both top-level INSERT statements and for nested INSERTs
// inside ASTUpdateItem. When used at the top-level, the target is always a
// path expression.
message ASTInsertStatementProto {
  optional ASTStatementProto parent = 1;
  optional AnyASTGeneralizedPathExpressionProto target_path = 2;
  optional ASTColumnListProto column_list = 3;
  // Non-NULL rows() means we had a VALUES clause.
  // This is mutually exclusive with query() and with().
  optional ASTInsertValuesRowListProto rows = 4;
  optional ASTQueryProto query = 5;
  optional ASTAssertRowsModifiedProto assert_rows_modified = 6;
  optional ASTReturningClauseProto returning = 7;
  // Deprecated
  optional int64 deprecated_parse_progress = 8;
  optional ASTInsertStatementEnums.InsertMode insert_mode = 9;
  optional ASTHintProto hint = 10;
  optional ASTOnConflictClauseProto on_conflict = 11;
}

message ASTUpdateSetValueProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTGeneralizedPathExpressionProto path = 2;
  // The rhs of SET X=Y.  May be ASTDefaultLiteral.
  optional AnyASTExpressionProto value = 3;
}

message ASTUpdateItemProto {
  optional ASTNodeProto parent = 1;
  optional ASTUpdateSetValueProto set_value = 2;
  optional ASTInsertStatementProto insert_statement = 3;
  optional ASTDeleteStatementProto delete_statement = 4;
  optional ASTUpdateStatementProto update_statement = 5;
}

message ASTUpdateItemListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTUpdateItemProto update_items = 2;
}

// This is used for both top-level UPDATE statements and for nested UPDATEs
// inside ASTUpdateItem. When used at the top-level, the target is always a
// path expression.
message ASTUpdateStatementProto {
  optional ASTStatementProto parent = 1;
  optional AnyASTGeneralizedPathExpressionProto target_path = 2;
  optional ASTAliasProto alias = 3;
  optional ASTWithOffsetProto offset = 4;
  optional ASTUpdateItemListProto update_item_list = 5;
  optional ASTFromClauseProto from_clause = 6;
  optional AnyASTExpressionProto where = 7;
  optional ASTAssertRowsModifiedProto assert_rows_modified = 8;
  optional ASTReturningClauseProto returning = 9;
  optional ASTHintProto hint = 10;
}

message ASTTruncateStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTPathExpressionProto target_path = 2;
  optional AnyASTExpressionProto where = 3;
}

message ASTMergeActionProto {
  optional ASTNodeProto parent = 1;
  // Exactly one of the INSERT/UPDATE/DELETE operation must be defined in
  // following ways,
  //   -- INSERT, action_type() is INSERT. The insert_column_list() is optional.
  //      The insert_row() must be non-null, but may have an empty value list.
  //   -- UPDATE, action_type() is UPDATE. update_item_list() is non-null.
  //   -- DELETE, action_type() is DELETE.
  optional ASTColumnListProto insert_column_list = 2;
  optional ASTInsertValuesRowProto insert_row = 3;
  optional ASTUpdateItemListProto update_item_list = 4;
  optional ASTMergeActionEnums.ActionType action_type = 5;
}

message ASTMergeWhenClauseProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto search_condition = 2;
  optional ASTMergeActionProto action = 3;
  optional ASTMergeWhenClauseEnums.MatchType match_type = 4;
}

message ASTMergeWhenClauseListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTMergeWhenClauseProto clause_list = 2;
}

message ASTMergeStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTPathExpressionProto target_path = 2;
  optional ASTAliasProto alias = 3;
  optional AnyASTTableExpressionProto table_expression = 4;
  optional AnyASTExpressionProto merge_condition = 5;
  optional ASTMergeWhenClauseListProto when_clauses = 6;
}

message ASTPrivilegeProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto privilege_action = 2;
  optional ASTPathExpressionListProto paths = 3;
}

// Represents privileges to be granted or revoked. It can be either or a
// non-empty list of ASTPrivilege, or "ALL PRIVILEGES" in which case the list
// will be empty.
message ASTPrivilegesProto {
  optional ASTNodeProto parent = 1;
  repeated ASTPrivilegeProto privileges = 2;
}

message ASTGranteeListProto {
  optional ASTNodeProto parent = 1;
  repeated AnyASTExpressionProto grantee_list = 2;
}

message ASTGrantStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTPrivilegesProto privileges = 2;
  repeated ASTIdentifierProto target_type_parts = 3;
  optional ASTPathExpressionProto target_path = 4;
  optional ASTGranteeListProto grantee_list = 5;
}

message ASTRevokeStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTPrivilegesProto privileges = 2;
  repeated ASTIdentifierProto target_type_parts = 3;
  optional ASTPathExpressionProto target_path = 4;
  optional ASTGranteeListProto grantee_list = 5;
}

message ASTRepeatableClauseProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto argument = 2;
}

message ASTFilterFieldsArgProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTGeneralizedPathExpressionProto path_expression = 2;
  optional ASTFilterFieldsArgEnums.FilterType filter_type = 3;
}

message ASTReplaceFieldsArgProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  optional AnyASTGeneralizedPathExpressionProto path_expression = 3;
}

message ASTReplaceFieldsExpressionProto {
  optional ASTExpressionProto parent = 1;
  optional AnyASTExpressionProto expr = 2;
  repeated ASTReplaceFieldsArgProto arguments = 3;
}

message ASTSampleSizeProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto size = 2;
  optional ASTPartitionByProto partition_by = 3;
  // Returns the token kind corresponding to the sample-size unit, i.e.
  // parser::ROWS or parser::PERCENT.
  optional ASTSampleSizeEnums.Unit unit = 4;
}

message ASTWithWeightProto {
  optional ASTNodeProto parent = 1;
  // alias may be NULL.
  optional ASTAliasProto alias = 2;
}

message ASTSampleSuffixProto {
  optional ASTNodeProto parent = 1;
  // weight and repeat may be NULL.
  optional ASTWithWeightProto weight = 2;
  optional ASTRepeatableClauseProto repeat = 3;
}

message ASTSampleClauseProto {
  optional ASTPostfixTableOperatorProto parent = 1;
  optional ASTIdentifierProto sample_method = 2;
  optional ASTSampleSizeProto sample_size = 3;
  optional ASTSampleSuffixProto sample_suffix = 4;
}

// Common parent for all actions in ALTER statements
message AnyASTAlterActionProto {
  oneof node {
    ASTSetOptionsActionProto ast_set_options_action_node = 234;
    ASTSetAsActionProto ast_set_as_action_node = 235;
    ASTAddConstraintActionProto ast_add_constraint_action_node = 236;
    ASTDropPrimaryKeyActionProto ast_drop_primary_key_action_node = 237;
    ASTDropConstraintActionProto ast_drop_constraint_action_node = 238;
    ASTAlterConstraintEnforcementActionProto ast_alter_constraint_enforcement_action_node = 239;
    ASTAlterConstraintSetOptionsActionProto ast_alter_constraint_set_options_action_node = 240;
    ASTAddColumnActionProto ast_add_column_action_node = 241;
    ASTDropColumnActionProto ast_drop_column_action_node = 242;
    ASTRenameColumnActionProto ast_rename_column_action_node = 243;
    ASTAlterColumnTypeActionProto ast_alter_column_type_action_node = 244;
    ASTAlterColumnOptionsActionProto ast_alter_column_options_action_node = 245;
    ASTAlterColumnDropNotNullActionProto ast_alter_column_drop_not_null_action_node = 246;
    ASTGrantToClauseProto ast_grant_to_clause_node = 247;
    ASTFilterUsingClauseProto ast_filter_using_clause_node = 248;
    ASTRevokeFromClauseProto ast_revoke_from_clause_node = 249;
    ASTRenameToClauseProto ast_rename_to_clause_node = 250;
    ASTSetCollateClauseProto ast_set_collate_clause_node = 251;
    ASTAlterColumnSetDefaultActionProto ast_alter_column_set_default_action_node = 322;
    ASTAlterColumnDropDefaultActionProto ast_alter_column_drop_default_action_node = 323;
    ASTRestrictToClauseProto ast_restrict_to_clause_node = 327;
    ASTAddToRestricteeListClauseProto ast_add_to_restrictee_list_clause_node = 328;
    ASTRemoveFromRestricteeListClauseProto ast_remove_from_restrictee_list_clause_node = 329;
    ASTAlterSubEntityActionProto ast_alter_sub_entity_action_node = 338;
    ASTAddSubEntityActionProto ast_add_sub_entity_action_node = 339;
    ASTDropSubEntityActionProto ast_drop_sub_entity_action_node = 340;
    ASTAddTtlActionProto ast_add_ttl_action_node = 349;
    ASTReplaceTtlActionProto ast_replace_ttl_action_node = 350;
    ASTDropTtlActionProto ast_drop_ttl_action_node = 351;
    ASTSpannerAlterColumnActionProto ast_spanner_alter_column_action_node = 352;
    ASTSpannerSetOnDeleteActionProto ast_spanner_set_on_delete_action_node = 353;
    ASTAlterColumnDropGeneratedActionProto ast_alter_column_drop_generated_action_node = 423;
    ASTAddColumnIdentifierActionProto ast_add_column_identifier_action_node = 516;
    ASTRebuildActionProto ast_rebuild_action_node = 517;
    ASTAlterColumnSetGeneratedActionProto ast_alter_column_set_generated_action_node = 528;
  }
}
message ASTAlterActionProto {
  optional ASTNodeProto parent = 1;
}

// ALTER action for "SET OPTIONS ()" clause
message ASTSetOptionsActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTOptionsListProto options_list = 2;
}

// ALTER action for "SET AS" clause
message ASTSetAsActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTJSONLiteralProto json_body = 2;
  optional ASTStringLiteralProto text_body = 3;
}

// ALTER table action for "ADD CONSTRAINT" clause
message ASTAddConstraintActionProto {
  optional ASTAlterActionProto parent = 1;
  optional AnyASTTableConstraintProto constraint = 2;
  optional bool is_if_not_exists = 3;
}

// ALTER table action for "DROP PRIMARY KEY" clause
message ASTDropPrimaryKeyActionProto {
  optional ASTAlterActionProto parent = 1;
  optional bool is_if_exists = 2;
}

// ALTER table action for "DROP CONSTRAINT" clause
message ASTDropConstraintActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTIdentifierProto constraint_name = 2;
  optional bool is_if_exists = 3;
}

// ALTER table action for "ALTER CONSTRAINT identifier [NOT] ENFORCED" clause
message ASTAlterConstraintEnforcementActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTIdentifierProto constraint_name = 2;
  optional bool is_if_exists = 3;
  optional bool is_enforced = 4;
}

// ALTER table action for "ALTER CONSTRAINT identifier SET OPTIONS" clause
message ASTAlterConstraintSetOptionsActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTIdentifierProto constraint_name = 2;
  optional ASTOptionsListProto options_list = 3;
  optional bool is_if_exists = 4;
}

// ALTER SEARCH|VECTOR INDEX action for "ADD COLUMN" clause.
// Note: Different from ASTAddColumnAction, this action is used for adding an
// existing column in table to an index, so it doesn't need column definition
// or other fields in ASTAddColumnAction.
message ASTAddColumnIdentifierActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTIdentifierProto column_name = 2;
  optional ASTOptionsListProto options_list = 3;
  optional bool is_if_not_exists = 4;
}

// ALTER table action for "ADD COLUMN" clause
message ASTAddColumnActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTColumnDefinitionProto column_definition = 2;
  // Optional children.
  optional ASTColumnPositionProto column_position = 3;
  optional AnyASTExpressionProto fill_expression = 4;
  optional bool is_if_not_exists = 5;
}

// ALTER table action for "DROP COLUMN" clause
message ASTDropColumnActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTIdentifierProto column_name = 2;
  optional bool is_if_exists = 3;
}

// ALTER table action for "RENAME COLUMN" clause
message ASTRenameColumnActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTIdentifierProto column_name = 2;
  optional ASTIdentifierProto new_column_name = 3;
  optional bool is_if_exists = 4;
}

// ALTER table action for "ALTER COLUMN SET TYPE" clause
message ASTAlterColumnTypeActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTIdentifierProto column_name = 2;
  optional AnyASTColumnSchemaProto schema = 3;
  optional ASTCollateProto collate = 4;
  optional bool is_if_exists = 5;
}

// ALTER table action for "ALTER COLUMN SET OPTIONS" clause
message ASTAlterColumnOptionsActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTIdentifierProto column_name = 2;
  optional ASTOptionsListProto options_list = 3;
  optional bool is_if_exists = 4;
}

// ALTER table action for "ALTER COLUMN SET DEFAULT" clause
message ASTAlterColumnSetDefaultActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTIdentifierProto column_name = 2;
  optional AnyASTExpressionProto default_expression = 3;
  optional bool is_if_exists = 4;
}

// ALTER table action for "ALTER COLUMN DROP DEFAULT" clause
message ASTAlterColumnDropDefaultActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTIdentifierProto column_name = 2;
  optional bool is_if_exists = 3;
}

// ALTER table action for "ALTER COLUMN DROP NOT NULL" clause
message ASTAlterColumnDropNotNullActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTIdentifierProto column_name = 2;
  optional bool is_if_exists = 3;
}

// ALTER table action for "ALTER COLUMN DROP GENERATED" clause
message ASTAlterColumnDropGeneratedActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTIdentifierProto column_name = 2;
  optional bool is_if_exists = 3;
}

// ALTER table action for "ALTER COLUMN SET GENERATED" clause
message ASTAlterColumnSetGeneratedActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTIdentifierProto column_name = 2;
  optional ASTGeneratedColumnInfoProto generated_column_info = 3;
  optional bool is_if_exists = 4;
}

// ALTER ROW ACCESS POLICY action for "GRANT TO (<grantee_list>)" or "TO
// <grantee_list>" clause, also used by CREATE ROW ACCESS POLICY
message ASTGrantToClauseProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTGranteeListProto grantee_list = 2;
  optional bool has_grant_keyword_and_parens = 3;
}

// ALTER PRIVILEGE RESTRICTION action for "RESTRICT TO (<restrictee_list>)"
// clause, also used by CREATE PRIVILEGE RESTRICTION
message ASTRestrictToClauseProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTGranteeListProto restrictee_list = 2;
}

// ALTER PRIVILEGE RESTRICTION action for "ADD (<restrictee_list>)" clause
message ASTAddToRestricteeListClauseProto {
  optional ASTAlterActionProto parent = 1;
  optional bool is_if_not_exists = 2;
  optional ASTGranteeListProto restrictee_list = 3;
}

// ALTER PRIVILEGE RESTRICTION action for "REMOVE (<restrictee_list>)" clause
message ASTRemoveFromRestricteeListClauseProto {
  optional ASTAlterActionProto parent = 1;
  optional bool is_if_exists = 2;
  optional ASTGranteeListProto restrictee_list = 3;
}

// ALTER ROW ACCESS POLICY action for "[FILTER] USING (<expression>)" clause,
// also used by CREATE ROW ACCESS POLICY
message ASTFilterUsingClauseProto {
  optional ASTAlterActionProto parent = 1;
  optional AnyASTExpressionProto predicate = 2;
  optional bool has_filter_keyword = 3;
}

// ALTER ROW ACCESS POLICY action for "REVOKE FROM (<grantee_list>)|ALL" clause
message ASTRevokeFromClauseProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTGranteeListProto revoke_from_list = 2;
  optional bool is_revoke_from_all = 3;
}

// ALTER ROW ACCESS POLICY action for "RENAME TO <new_name>" clause,
// and ALTER table action for "RENAME TO" clause.
message ASTRenameToClauseProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTPathExpressionProto new_name = 2;
}

// ALTER action for "SET COLLATE ()" clause
message ASTSetCollateClauseProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTCollateProto collate = 2;
}

// ALTER action for "ALTER <subentity>" clause
message ASTAlterSubEntityActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTIdentifierProto type = 2;
  optional ASTIdentifierProto name = 3;
  optional AnyASTAlterActionProto action = 4;
  optional bool is_if_exists = 5;
}

// ALTER action for "ADD <subentity>" clause
message ASTAddSubEntityActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTIdentifierProto type = 2;
  optional ASTIdentifierProto name = 3;
  optional ASTOptionsListProto options_list = 4;
  optional bool is_if_not_exists = 5;
}

// ALTER action for "DROP <subentity>" clause
message ASTDropSubEntityActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTIdentifierProto type = 2;
  optional ASTIdentifierProto name = 3;
  optional bool is_if_exists = 5;
}

// ALTER action for "ADD ROW DELETION POLICY clause
message ASTAddTtlActionProto {
  optional ASTAlterActionProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  optional bool is_if_not_exists = 3;
}

// ALTER action for "REPLACE ROW DELETION POLICY clause
message ASTReplaceTtlActionProto {
  optional ASTAlterActionProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  optional bool is_if_exists = 3;
}

// ALTER action for "DROP ROW DELETION POLICY clause
message ASTDropTtlActionProto {
  optional ASTAlterActionProto parent = 1;
  optional bool is_if_exists = 2;
}

message ASTAlterActionListProto {
  optional ASTNodeProto parent = 1;
  repeated AnyASTAlterActionProto actions = 2;
}

message ASTAlterAllRowAccessPoliciesStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTPathExpressionProto table_name_path = 2;
  optional AnyASTAlterActionProto alter_action = 3;
}

message ASTForeignKeyActionsProto {
  optional ASTNodeProto parent = 1;
  optional ASTForeignKeyActionsEnums.Action update_action = 2;
  optional ASTForeignKeyActionsEnums.Action delete_action = 3;
}

message ASTForeignKeyReferenceProto {
  optional ASTNodeProto parent = 1;
  optional ASTPathExpressionProto table_name = 2;
  optional ASTColumnListProto column_list = 3;
  optional ASTForeignKeyActionsProto actions = 4;
  optional ASTForeignKeyReferenceEnums.Match match = 5;
  optional bool enforced = 6;
}

// A top-level script.
message ASTScriptProto {
  optional ASTNodeProto parent = 1;
  optional ASTStatementListProto statement_list_node = 2;
}

// Represents an ELSEIF clause in an IF statement.
message ASTElseifClauseProto {
  optional ASTNodeProto parent = 1;
  // condition and body are both required.
  optional AnyASTExpressionProto condition = 2;
  optional ASTStatementListProto body = 3;
}

// Represents a list of ELSEIF clauses.  Note that this list is never empty,
// as the grammar will not create an ASTElseifClauseList object unless there
// exists at least one ELSEIF clause.
message ASTElseifClauseListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTElseifClauseProto elseif_clauses = 2;
}

message ASTIfStatementProto {
  optional ASTScriptStatementProto parent = 1;
  // condition and then_list are both required.
  optional AnyASTExpressionProto condition = 2;
  optional ASTStatementListProto then_list = 3;
  // Optional; nullptr if no ELSEIF clauses are specified.  If present, the
  // list will never be empty.
  optional ASTElseifClauseListProto elseif_clauses = 4;
  // Optional; nullptr if no ELSE clause is specified
  optional ASTStatementListProto else_list = 5;
}

// Represents a WHEN...THEN clause in a CASE statement.
message ASTWhenThenClauseProto {
  optional ASTNodeProto parent = 1;
  // condition and body are both required.
  optional AnyASTExpressionProto condition = 2;
  optional ASTStatementListProto body = 3;
}

// Represents a list of WHEN...THEN clauses. Note that this list is never empty,
// as the grammar mandates that there is at least one WHEN...THEN clause in
// a CASE statement.
message ASTWhenThenClauseListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTWhenThenClauseProto when_then_clauses = 2;
}

message ASTCaseStatementProto {
  optional ASTScriptStatementProto parent = 1;
  // Optional; nullptr if not specified
  optional AnyASTExpressionProto expression = 2;
  // Required field.
  optional ASTWhenThenClauseListProto when_then_clauses = 3;
  optional ASTStatementListProto else_list = 4;
}

message ASTHintProto {
  optional ASTNodeProto parent = 1;
  // This is the @num_shards hint shorthand that can occur anywhere that a
  // hint can occur, prior to @{...} hints.
  // At least one of num_shards_hints is non-NULL or hint_entries is non-empty.
  optional ASTIntLiteralProto num_shards_hint = 2;
  repeated ASTHintEntryProto hint_entries = 3;
}

message ASTHintEntryProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto qualifier = 2;
  optional ASTIdentifierProto name = 3;
  // Value may be any expression; engines can decide whether they
  // support identifiers, literals, parameters, constants, etc.
  optional AnyASTExpressionProto value = 4;
}

message ASTUnpivotInItemLabelProto {
  optional ASTNodeProto parent = 1;
  optional ASTStringLiteralProto string_label = 2;
  optional ASTIntLiteralProto int_label = 3;
}

message ASTDescriptorProto {
  optional ASTNodeProto parent = 1;
  optional ASTDescriptorColumnListProto columns = 2;
}

// A column schema identifies the column type and the column annotations.
// The annotations consist of the column attributes and the column options.
//
// This class is used only in column definitions of CREATE TABLE statements,
// and is unrelated to CREATE SCHEMA despite the usage of the overloaded term
// "schema".
//
// The hierarchy of column schema is similar to the type hierarchy.
// The annotations can be applied on struct fields or array elements, for
// example, as in STRUCT<x INT64 NOT NULL, y STRING OPTIONS(foo="bar")>.
// In this case, some column attributes, such as PRIMARY KEY and HIDDEN, are
// disallowed as field attributes.
message AnyASTColumnSchemaProto {
  oneof node {
    ASTSimpleColumnSchemaProto ast_simple_column_schema_node = 268;
    ASTStructColumnSchemaProto ast_struct_column_schema_node = 316;
    ASTInferredTypeColumnSchemaProto ast_inferred_type_column_schema_node = 317;
    AnyASTElementTypeColumnSchemaProto ast_element_type_column_schema_node = 382;
  }
}
message ASTColumnSchemaProto {
  optional ASTNodeProto parent = 1;
  optional ASTTypeParameterListProto type_parameters = 2;
  optional ASTGeneratedColumnInfoProto generated_column_info = 3;
  optional AnyASTExpressionProto default_expression = 4;
  optional ASTCollateProto collate = 5;
  optional ASTColumnAttributeListProto attributes = 6;
  optional ASTOptionsListProto options_list = 7;
}

message ASTSimpleColumnSchemaProto {
  optional ASTColumnSchemaProto parent = 1;
  optional ASTPathExpressionProto type_name = 2;
}

// Base class for column schemas that are also defined by an element type (eg
// ARRAY and RANGE).
message AnyASTElementTypeColumnSchemaProto {
  oneof node {
    ASTArrayColumnSchemaProto ast_array_column_schema_node = 269;
    ASTRangeColumnSchemaProto ast_range_column_schema_node = 383;
  }
}
message ASTElementTypeColumnSchemaProto {
  optional ASTColumnSchemaProto parent = 1;
  optional AnyASTColumnSchemaProto element_schema = 2;
}

message ASTArrayColumnSchemaProto {
  optional ASTElementTypeColumnSchemaProto parent = 1;
}

message ASTRangeColumnSchemaProto {
  optional ASTElementTypeColumnSchemaProto parent = 1;
}

message ASTPrimaryKeyElementProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto column = 2;
  optional ASTOrderingExpressionEnums.OrderingSpec ordering_spec = 3;
  optional ASTNullOrderProto null_order = 4;
}

message ASTPrimaryKeyElementListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTPrimaryKeyElementProto elements = 2;
}

// Base class for constraints, including primary key, foreign key and check
// constraints.
message AnyASTTableConstraintProto {
  oneof node {
    ASTPrimaryKeyProto ast_primary_key_node = 271;
    ASTForeignKeyProto ast_foreign_key_node = 272;
    ASTCheckConstraintProto ast_check_constraint_node = 273;
  }
}
message ASTTableConstraintProto {
  optional ASTTableElementProto parent = 1;
}

message ASTPrimaryKeyProto {
  optional ASTTableConstraintProto parent = 1;
  optional ASTPrimaryKeyElementListProto element_list = 2;
  optional ASTOptionsListProto options_list = 3;
  optional ASTIdentifierProto constraint_name = 4;
  optional bool enforced = 5;
}

message ASTForeignKeyProto {
  optional ASTTableConstraintProto parent = 1;
  optional ASTColumnListProto column_list = 2;
  optional ASTForeignKeyReferenceProto reference = 3;
  optional ASTOptionsListProto options_list = 4;
  optional ASTIdentifierProto constraint_name = 5;
}

message ASTCheckConstraintProto {
  optional ASTTableConstraintProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  optional ASTOptionsListProto options_list = 3;
  optional ASTIdentifierProto constraint_name = 4;
  optional bool is_enforced = 5;
}

message ASTDescriptorColumnProto {
  optional ASTNodeProto parent = 1;
  // Required field
  optional ASTIdentifierProto name = 2;
}

message ASTDescriptorColumnListProto {
  optional ASTNodeProto parent = 1;
  // Guaranteed by the parser to never be empty.
  repeated ASTDescriptorColumnProto descriptor_column_list = 2;
}

message ASTCreateEntityStatementProto {
  optional ASTCreateStatementProto parent = 1;
  optional ASTIdentifierProto type = 2;
  optional ASTPathExpressionProto name = 3;
  optional ASTOptionsListProto options_list = 4;
  optional ASTJSONLiteralProto json_body = 5;
  optional ASTStringLiteralProto text_body = 6;
}

message ASTRaiseStatementProto {
  optional ASTScriptStatementProto parent = 1;
  optional AnyASTExpressionProto message = 2;
}

message ASTExceptionHandlerProto {
  optional ASTNodeProto parent = 1;
  // Required field; even an empty block still contains an empty statement list.
  optional ASTStatementListProto statement_list = 2;
}

// Represents a list of exception handlers in a block.  Currently restricted
// to one element, but may contain multiple elements in the future, once there
// are multiple error codes for a block to catch.
message ASTExceptionHandlerListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTExceptionHandlerProto exception_handler_list = 2;
}

message ASTBeginEndBlockProto {
  optional ASTScriptStatementProto parent = 1;
  optional ASTLabelProto label = 2;
  optional ASTStatementListProto statement_list_node = 3;
  // Optional; nullptr indicates a BEGIN block without an EXCEPTION clause.
  optional ASTExceptionHandlerListProto handler_list = 4;
}

message ASTIdentifierListProto {
  optional ASTNodeProto parent = 1;
  // Guaranteed by the parser to never be empty.
  repeated ASTIdentifierProto identifier_list = 2;
}

message ASTVariableDeclarationProto {
  optional ASTScriptStatementProto parent = 1;
  // Required fields
  optional ASTIdentifierListProto variable_list = 2;
  // Optional fields; at least one of <type> and <default_value> must be
  // present.
  optional AnyASTTypeProto type = 3;
  optional AnyASTExpressionProto default_value = 4;
}

// Represents UNTIL in a REPEAT statement.
message ASTUntilClauseProto {
  optional ASTNodeProto parent = 1;
  // Required field
  optional AnyASTExpressionProto condition = 2;
}

// Base class shared by break and continue statements.
message AnyASTBreakContinueStatementProto {
  oneof node {
    ASTBreakStatementProto ast_break_statement_node = 285;
    ASTContinueStatementProto ast_continue_statement_node = 286;
  }
}
message ASTBreakContinueStatementProto {
  optional ASTScriptStatementProto parent = 1;
  optional ASTLabelProto label = 2;
}

message ASTBreakStatementProto {
  optional ASTBreakContinueStatementProto parent = 1;
  optional ASTBreakContinueStatementEnums.BreakContinueKeyword keyword = 2;
}

message ASTContinueStatementProto {
  optional ASTBreakContinueStatementProto parent = 1;
  optional ASTBreakContinueStatementEnums.BreakContinueKeyword keyword = 2;
}

message ASTDropPrivilegeRestrictionStatementProto {
  optional ASTDdlStatementProto parent = 1;
  optional bool is_if_exists = 2;
  optional ASTPrivilegesProto privileges = 3;
  optional ASTIdentifierProto object_type = 4;
  optional ASTPathExpressionProto name_path = 5;
}

// Represents a DROP ROW ACCESS POLICY statement.
message ASTDropRowAccessPolicyStatementProto {
  optional ASTDdlStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTPathExpressionProto table_name = 3;
  optional bool is_if_exists = 4;
}

message ASTCreatePrivilegeRestrictionStatementProto {
  optional ASTCreateStatementProto parent = 1;
  optional ASTPrivilegesProto privileges = 2;
  optional ASTIdentifierProto object_type = 3;
  optional ASTPathExpressionProto name_path = 4;
  optional ASTRestrictToClauseProto restrict_to = 5;
}

message ASTCreateRowAccessPolicyStatementProto {
  optional ASTCreateStatementProto parent = 1;
  optional ASTPathExpressionProto target_path = 2;
  optional ASTGrantToClauseProto grant_to = 3;
  optional ASTFilterUsingClauseProto filter_using = 4;
  optional ASTPathExpressionProto name = 5;
  optional bool has_access_keyword = 6;
}

// Represents a DROP statement.
message ASTDropStatementProto {
  optional ASTDdlStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTDropStatementEnums.DropMode drop_mode = 3;
  optional bool is_if_exists = 4;
  optional SchemaObjectKind schema_object_kind = 5;
}

message ASTReturnStatementProto {
  optional ASTScriptStatementProto parent = 1;
}

// A statement which assigns to a single variable from an expression.
// Example:
//   SET x = 3;
message ASTSingleAssignmentProto {
  optional ASTScriptStatementProto parent = 1;
  optional ASTIdentifierProto variable = 2;
  optional AnyASTExpressionProto expression = 3;
}

// A statement which assigns to a query parameter from an expression.
// Example:
//   SET @x = 3;
message ASTParameterAssignmentProto {
  optional ASTStatementProto parent = 1;
  optional ASTParameterExprProto parameter = 2;
  optional AnyASTExpressionProto expression = 3;
}

// A statement which assigns to a system variable from an expression.
// Example:
//   SET @@x = 3;
message ASTSystemVariableAssignmentProto {
  optional ASTStatementProto parent = 1;
  optional ASTSystemVariableExprProto system_variable = 2;
  optional AnyASTExpressionProto expression = 3;
}

// A statement which assigns multiple variables to fields in a struct,
// which each variable assigned to one field.
// Example:
//   SET (x, y) = (5, 10);
message ASTAssignmentFromStructProto {
  optional ASTScriptStatementProto parent = 1;
  optional ASTIdentifierListProto variables = 2;
  optional AnyASTExpressionProto struct_expression = 3;
}

message AnyASTCreateTableStmtBaseProto {
  oneof node {
    ASTCreateTableStatementProto ast_create_table_statement_node = 296;
    ASTCreateExternalTableStatementProto ast_create_external_table_statement_node = 297;
    ASTAuxLoadDataStatementProto ast_aux_load_data_statement_node = 342;
  }
}
message ASTCreateTableStmtBaseProto {
  optional ASTCreateStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTTableElementListProto table_element_list = 3;
  optional ASTOptionsListProto options_list = 4;
  optional ASTPathExpressionProto like_table_name = 5;
  optional ASTCollateProto collate = 6;
  optional ASTWithConnectionClauseProto with_connection_clause = 7;
}

message ASTCreateTableStatementProto {
  optional ASTCreateTableStmtBaseProto parent = 1;
  optional ASTCloneDataSourceProto clone_data_source = 2;
  optional ASTCopyDataSourceProto copy_data_source = 3;
  optional ASTPartitionByProto partition_by = 4;
  optional ASTClusterByProto cluster_by = 5;
  optional ASTQueryProto query = 6;
  optional ASTSpannerTableOptionsProto spanner_options = 7;
  optional ASTTtlClauseProto ttl = 8;
}

message ASTCreateExternalTableStatementProto {
  optional ASTCreateTableStmtBaseProto parent = 1;
  optional ASTWithPartitionColumnsClauseProto with_partition_columns_clause = 2;
}

message AnyASTCreateViewStatementBaseProto {
  oneof node {
    ASTCreateViewStatementProto ast_create_view_statement_node = 299;
    ASTCreateMaterializedViewStatementProto ast_create_materialized_view_statement_node = 300;
    ASTCreateApproxViewStatementProto ast_create_approx_view_statement_node = 397;
  }
}
message ASTCreateViewStatementBaseProto {
  optional ASTCreateStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTColumnWithOptionsListProto column_with_options_list = 3;
  optional ASTOptionsListProto options_list = 4;
  optional ASTQueryProto query = 5;
  optional ASTCreateStatementEnums.SqlSecurity sql_security = 6;
  optional bool recursive = 7;
}

message ASTCreateViewStatementProto {
  optional ASTCreateViewStatementBaseProto parent = 1;
}

message ASTCreateMaterializedViewStatementProto {
  optional ASTCreateViewStatementBaseProto parent = 1;
  optional ASTPartitionByProto partition_by = 2;
  optional ASTClusterByProto cluster_by = 3;
  optional ASTPathExpressionProto replica_source = 4;
}

message ASTCreateApproxViewStatementProto {
  optional ASTCreateViewStatementBaseProto parent = 1;
}

// Base class for all loop statements (loop/end loop, while, foreach, etc.).
// Every loop has a body.
message AnyASTLoopStatementProto {
  oneof node {
    ASTWhileStatementProto ast_while_statement_node = 302;
    ASTRepeatStatementProto ast_repeat_statement_node = 303;
    ASTForInStatementProto ast_for_in_statement_node = 304;
  }
}
message ASTLoopStatementProto {
  optional ASTScriptStatementProto parent = 1;
  // Optional field
  optional ASTLabelProto label = 2;
  // Required field
  optional ASTStatementListProto body = 3;
}

// Represents either:
// - LOOP...END LOOP (if condition is nullptr).  This is semantically
//                  equivalent to WHILE(true)...END WHILE.
// - WHILE...END WHILE (if condition is not nullptr)
message ASTWhileStatementProto {
  optional ASTLoopStatementProto parent = 1;
  // The <condition> is optional.  A null <condition> indicates a
  // LOOP...END LOOP construct.
  optional AnyASTExpressionProto condition = 2;
}

// Represents the statement REPEAT...UNTIL...END REPEAT.
// This is conceptually also called do-while.
message ASTRepeatStatementProto {
  optional ASTLoopStatementProto parent = 1;
  // Required field.
  optional ASTUntilClauseProto until_clause = 2;
}

// Represents the statement FOR...IN...DO...END FOR.
// This is conceptually also called for-each.
message ASTForInStatementProto {
  optional ASTLoopStatementProto parent = 1;
  optional ASTIdentifierProto variable = 2;
  optional ASTQueryProto query = 3;
}

// Common parent class for ALTER statement, e.g., ALTER TABLE/ALTER VIEW
message AnyASTAlterStatementBaseProto {
  oneof node {
    ASTAlterDatabaseStatementProto ast_alter_database_statement_node = 306;
    ASTAlterSchemaStatementProto ast_alter_schema_statement_node = 307;
    ASTAlterTableStatementProto ast_alter_table_statement_node = 308;
    ASTAlterViewStatementProto ast_alter_view_statement_node = 309;
    ASTAlterMaterializedViewStatementProto ast_alter_materialized_view_statement_node = 310;
    ASTAlterRowAccessPolicyStatementProto ast_alter_row_access_policy_statement_node = 311;
    ASTAlterEntityStatementProto ast_alter_entity_statement_node = 312;
    ASTAlterPrivilegeRestrictionStatementProto ast_alter_privilege_restriction_statement_node = 325;
    ASTAlterModelStatementProto ast_alter_model_statement_node = 336;
    ASTAlterApproxViewStatementProto ast_alter_approx_view_statement_node = 396;
    ASTAlterExternalSchemaStatementProto ast_alter_external_schema_statement_node = 440;
    ASTAlterConnectionStatementProto ast_alter_connection_statement_node = 480;
    ASTAlterIndexStatementProto ast_alter_index_statement_node = 518;
    ASTAlterSequenceStatementProto ast_alter_sequence_statement_node = 533;
  }
}
message ASTAlterStatementBaseProto {
  optional ASTDdlStatementProto parent = 1;
  optional ASTPathExpressionProto path = 2;
  optional ASTAlterActionListProto action_list = 3;
  optional bool is_if_exists = 4;
}

// Represents the statement ALTER CONNECTION <name_path> SET OPTIONS
// <options_list>
message ASTAlterConnectionStatementProto {
  optional ASTAlterStatementBaseProto parent = 1;
}

message ASTAlterDatabaseStatementProto {
  optional ASTAlterStatementBaseProto parent = 1;
}

message ASTAlterSchemaStatementProto {
  optional ASTAlterStatementBaseProto parent = 1;
}

message ASTAlterExternalSchemaStatementProto {
  optional ASTAlterStatementBaseProto parent = 1;
}

message ASTAlterTableStatementProto {
  optional ASTAlterStatementBaseProto parent = 1;
}

message ASTAlterViewStatementProto {
  optional ASTAlterStatementBaseProto parent = 1;
}

message ASTAlterMaterializedViewStatementProto {
  optional ASTAlterStatementBaseProto parent = 1;
}

message ASTAlterApproxViewStatementProto {
  optional ASTAlterStatementBaseProto parent = 1;
}

message ASTAlterModelStatementProto {
  optional ASTAlterStatementBaseProto parent = 1;
}

message ASTAlterPrivilegeRestrictionStatementProto {
  optional ASTAlterStatementBaseProto parent = 1;
  // Required field.
  optional ASTPrivilegesProto privileges = 2;
  // Required field.
  optional ASTIdentifierProto object_type = 3;
}

message ASTAlterRowAccessPolicyStatementProto {
  optional ASTAlterStatementBaseProto parent = 1;
  // Required field.
  optional ASTIdentifierProto name = 2;
}

message ASTAlterEntityStatementProto {
  optional ASTAlterStatementBaseProto parent = 1;
  optional ASTIdentifierProto type = 2;
}

// ALTER SEARCH|VECTOR INDEX action for "REBUILD" clause.
message ASTRebuildActionProto {
  optional ASTAlterActionProto parent = 1;
}

// Represents a ALTER SEARCH|VECTOR INDEX statement.
// Note: ALTER INDEX without SEARCH or VECTOR is currently resolved to
// schema_object_kind, and throws not supported error.
message ASTAlterIndexStatementProto {
  optional ASTAlterStatementBaseProto parent = 1;
  optional ASTPathExpressionProto table_name = 2;
  optional ASTAlterIndexStatementEnums.IndexType index_type = 3;
}

// This is the common superclass of CREATE FUNCTION and CREATE TABLE FUNCTION
// statements. It contains all fields shared between the two types of
// statements, including the function declaration, return type, OPTIONS list,
// and string body (if present).
message AnyASTCreateFunctionStmtBaseProto {
  oneof node {
    ASTCreateFunctionStatementProto ast_create_function_statement_node = 314;
    ASTCreateTableFunctionStatementProto ast_create_table_function_statement_node = 315;
  }
}
message ASTCreateFunctionStmtBaseProto {
  optional ASTCreateStatementProto parent = 1;
  optional ASTFunctionDeclarationProto function_declaration = 2;
  optional ASTIdentifierProto language = 3;
  optional ASTStringLiteralProto code = 4;
  optional ASTOptionsListProto options_list = 5;
  optional ASTCreateFunctionStmtBaseEnums.DeterminismLevel determinism_level = 6;
  optional ASTCreateStatementEnums.SqlSecurity sql_security = 7;
}

// This may represent an "external language" function (e.g., implemented in a
// non-SQL programming language such as JavaScript), a "sql" function, or a
// "remote" function (e.g., implemented in a remote service and with an agnostic
// programming language).
// Note that some combinations of field setting can represent functions that are
// not actually valid due to optional members that would be inappropriate for
// one type of function or another; validity of the parsed function must be
// checked by the analyzer.
message ASTCreateFunctionStatementProto {
  optional ASTCreateFunctionStmtBaseProto parent = 1;
  optional AnyASTTypeProto return_type = 2;
  optional ASTSqlFunctionBodyProto sql_function_body = 3;
  optional bool is_aggregate = 4;
  optional bool is_remote = 5;
  optional ASTWithConnectionClauseProto with_connection_clause = 6;
}

// This represents a table-valued function declaration statement in ZetaSQL,
// using the CREATE TABLE FUNCTION syntax. Note that some combinations of field
// settings can represent functions that are not actually valid, since optional
// members may be inappropriate for one type of function or another; validity of
// the parsed function must be checked by the analyzer.
message ASTCreateTableFunctionStatementProto {
  optional ASTCreateFunctionStmtBaseProto parent = 1;
  optional ASTTVFSchemaProto return_tvf_schema = 2;
  optional ASTQueryProto query = 3;
}

message ASTStructColumnSchemaProto {
  optional ASTColumnSchemaProto parent = 1;
  repeated ASTStructColumnFieldProto struct_fields = 2;
}

message ASTInferredTypeColumnSchemaProto {
  optional ASTColumnSchemaProto parent = 1;
}

message ASTExecuteIntoClauseProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierListProto identifiers = 2;
}

message ASTExecuteUsingArgumentProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
  // Optional. Absent if this argument is positional. Present if it is named.
  optional ASTAliasProto alias = 3;
}

message ASTExecuteUsingClauseProto {
  optional ASTNodeProto parent = 1;
  repeated ASTExecuteUsingArgumentProto arguments = 2;
}

message ASTExecuteImmediateStatementProto {
  optional ASTStatementProto parent = 1;
  optional AnyASTExpressionProto sql = 2;
  optional ASTExecuteIntoClauseProto into_clause = 3;
  optional ASTExecuteUsingClauseProto using_clause = 4;
}

message ASTAuxLoadDataFromFilesOptionsListProto {
  optional ASTNodeProto parent = 1;
  optional ASTOptionsListProto options_list = 2;
}

message ASTAuxLoadDataPartitionsClauseProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto partition_filter = 2;
  optional bool is_overwrite = 3;
}

// Auxiliary statement used by some engines but not formally part of the
// ZetaSQL language.
message ASTAuxLoadDataStatementProto {
  optional ASTCreateTableStmtBaseProto parent = 1;
  optional ASTAuxLoadDataStatementEnums.InsertionMode insertion_mode = 2;
  optional ASTPartitionByProto partition_by = 3;
  optional ASTClusterByProto cluster_by = 4;
  optional ASTAuxLoadDataFromFilesOptionsListProto from_files = 5;
  optional ASTWithPartitionColumnsClauseProto with_partition_columns_clause = 6;
  optional ASTAuxLoadDataPartitionsClauseProto load_data_partitions_clause = 8;
  optional bool is_temp_table = 9;
}

message ASTLabelProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto name = 2;
}

message ASTWithExpressionProto {
  optional ASTExpressionProto parent = 1;
  optional ASTSelectListProto variables = 2;
  optional AnyASTExpressionProto expression = 3;
}

message ASTTtlClauseProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto expression = 2;
}

// A non-functional node used only to carry a location for better error
// messages.
message ASTLocationProto {
  optional ASTNodeProto parent = 1;
}

message ASTInputOutputClauseProto {
  optional ASTNodeProto parent = 1;
  optional ASTTableElementListProto input = 2;
  optional ASTTableElementListProto output = 3;
}

// Represents Spanner-specific extensions for CREATE TABLE statement.
message ASTSpannerTableOptionsProto {
  optional ASTNodeProto parent = 1;
  optional ASTPrimaryKeyProto primary_key = 2;
  optional ASTSpannerInterleaveClauseProto interleave_clause = 3;
}

// Represents an INTERLEAVE clause used in Spanner-specific DDL statements.
message ASTSpannerInterleaveClauseProto {
  optional ASTNodeProto parent = 1;
  optional ASTPathExpressionProto table_name = 2;
  optional ASTSpannerInterleaveClauseEnums.Type type = 3;
  optional ASTForeignKeyActionsEnums.Action action = 4;
}

// ALTER TABLE action for Spanner-specific "ALTER COLUMN" clause
message ASTSpannerAlterColumnActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTColumnDefinitionProto column_definition = 2;
}

// ALTER TABLE action for Spanner-specific "SET ON DELETE" clause
message ASTSpannerSetOnDeleteActionProto {
  optional ASTAlterActionProto parent = 1;
  optional ASTForeignKeyActionsEnums.Action action = 2;
}

// This node results from ranges constructed with the RANGE keyword followed
// by a literal. Example:
//   RANGE<DATE> '[2022-08-01, 2022-08-02)'
//   RANGE<TIMESTAMP> '[2020-10-01 12:00:00+08, 2020-12-31 12:00:00+08)';
message ASTRangeLiteralProto {
  optional ASTExpressionProto parent = 1;
  optional ASTRangeTypeProto type = 2;
  // String literal representing the range, must have format
  // "[range start, range end)" where "range start" and "range end"
  // are literals of the type specified RANGE<type>
  optional ASTStringLiteralProto range_value = 3;
}

message ASTRangeTypeProto {
  optional ASTTypeProto parent = 1;
  optional AnyASTTypeProto element_type = 2;
  optional ASTTypeParameterListProto type_parameters = 3;
  optional ASTCollateProto collate = 4;
}

message ASTCreatePropertyGraphStatementProto {
  optional ASTCreateStatementProto parent = 1;
  // Path expression for the target property graph.
  optional ASTPathExpressionProto name = 2;
  // GraphNodeTable definitions.
  optional ASTGraphElementTableListProto node_table_list = 3;
  // GraphEdgeTable definitions.
  optional ASTGraphElementTableListProto edge_table_list = 4;
  // Placeholder for now. Schema options support is out of scope of MVP.
  optional ASTOptionsListProto options_list = 5;
}

message ASTGraphElementTableListProto {
  optional ASTNodeProto parent = 1;
  // GraphElementTable definitions.
  repeated ASTGraphElementTableProto element_tables = 2;
}

message ASTGraphElementTableProto {
  optional ASTNodeProto parent = 1;
  // GraphElementTable identifier. There should exist an underlying
  // table with the same name.
  optional ASTPathExpressionProto name = 2;
  // GraphElementTable alias.
  optional ASTAliasProto alias = 3;
  // List of columns that uniquely identifies a row in GraphElementTable.
  optional ASTColumnListProto key_list = 4;
  // GraphEdgeTable should have this field referencing source node of the edge.
  optional ASTGraphNodeTableReferenceProto source_node_reference = 5;
  // GraphEdgeTable should have this field referencing destination node of the edge.
  optional ASTGraphNodeTableReferenceProto dest_node_reference = 6;
  // List of Labels exposed by this ElementTable, along with the
  // Properties exposed by the Label. This list can never be empty.
  optional ASTGraphElementLabelAndPropertiesListProto label_properties_list = 7;
  // If present, this is the dynamic label(s) exposed by
  // this ElementTable.
  optional ASTGraphDynamicLabelProto dynamic_label = 8;
  // If present, this is the dynamic properties exposed by
  // this ElementTable.
  optional ASTGraphDynamicPropertiesProto dynamic_properties = 9;
}

message ASTGraphNodeTableReferenceProto {
  optional ASTNodeProto parent = 1;
  // Referenced GraphNodeTable alias
  optional ASTIdentifierProto node_table_identifier = 2;
  // GraphEdgeTable columns referencing GraphNodeTable columns.
  optional ASTColumnListProto edge_table_columns = 3;
  // GraphNodeTable columns referenced by GraphEdgeTable
  optional ASTColumnListProto node_table_columns = 4;
  optional ASTGraphNodeTableReferenceEnums.NodeReferenceType node_reference_type = 5;
}

message ASTGraphElementLabelAndPropertiesListProto {
  optional ASTNodeProto parent = 1;
  // This can never be empty.
  repeated ASTGraphElementLabelAndPropertiesProto label_properties_list = 2;
}

message ASTGraphElementLabelAndPropertiesProto {
  optional ASTNodeProto parent = 1;
  // Label of the element table.
  // If NULL, it is equivalent to explicitly specifying "DEFAULT LABEL" in
  // the element table definition.
  optional ASTIdentifierProto label_name = 2;
  // Properties exposed by the label.
  optional ASTGraphPropertiesProto properties = 3;
  // Options associated with the label.
  optional ASTOptionsListProto label_options_list = 4;
}

// <expression> [AS <alias>] [OPTIONS (<options>)]
message ASTGraphDerivedPropertyProto {
  optional ASTNodeProto parent = 1;
  // Sql expression for the property.
  optional AnyASTExpressionProto expression = 2;
  // Alias for the property.
  optional ASTAliasProto alias = 3;
  // Options associated with the property definition.
  optional ASTOptionsListProto options_list = 4;
}

message ASTGraphDerivedPropertyListProto {
  optional ASTNodeProto parent = 1;
  // This can never be empty.
  repeated ASTGraphDerivedPropertyProto properties = 2;
}

message ASTGraphPropertiesProto {
  optional ASTNodeProto parent = 1;
  // If true, derived_property_list and all_except_columns are ignored.
  // It means NO PROPERTIES
  optional bool no_properties = 2;
  // no_properties must be false for the following to take effect:
  // If NULL, it means: PROPERTIES [ARE] ALL COLUMNS.
  // If not NULL, it means: PROPERTIES(<derived property list>);
  optional ASTGraphDerivedPropertyListProto derived_property_list = 3;
  // no_properties must be false and derived_property_list must be
  // NULL for the following to take effect:
  // If not NULL, it appends optional EXCEPT(<all_except_columns>)
  // list to PROPERTIES [ARE] ALL COLUMNS.
  optional ASTColumnListProto all_except_columns = 4;
}

message ASTGraphDynamicLabelProto {
  optional ASTNodeProto parent = 1;
  // Label expression.
  optional AnyASTExpressionProto label = 2;
}

message ASTGraphDynamicPropertiesProto {
  optional ASTNodeProto parent = 1;
  // Properties expression.
  optional AnyASTExpressionProto properties = 2;
}

// Represents a <graph pattern>
message ASTGraphPatternProto {
  optional ASTNodeProto parent = 1;
  repeated ASTGraphPathPatternProto paths = 2;
  optional ASTWhereClauseProto where_clause = 3;
}

// This represents a graph query expression which can only be produced
// by either a top level graph query statement, or a subquery expression.
// See below docs for details:
// - (broken link):top-level-gql-query-statement
// - (broken link):gql-subquery
message ASTGqlQueryProto {
  optional ASTQueryExpressionProto parent = 1;
  optional ASTGraphTableQueryProto graph_table = 2;
}

// This represents a graph query expression that only contains a
// graph pattern. It can be used to construct an "EXISTS" graph subquery
// expression.
message ASTGqlGraphPatternQueryProto {
  optional ASTQueryExpressionProto parent = 1;
  // Optional path expression for the target property graph.
  optional ASTPathExpressionProto graph_reference = 2;
  optional ASTGraphPatternProto graph_pattern = 3;
}

// This represents a graph query expression that only contains an
// ASTGqlOperatorList. It can be used to construct an "EXISTS"
// graph subquery expression with RETURN operator omitted.
message ASTGqlLinearOpsQueryProto {
  optional ASTQueryExpressionProto parent = 1;
  // Optional path expression for the target property graph.
  optional ASTPathExpressionProto graph_reference = 2;
  optional ASTGqlOperatorListProto linear_ops = 3;
}

// Represents a GRAPH_TABLE() query
message ASTGraphTableQueryProto {
  optional ASTTableExpressionProto parent = 1;
  // Path expression for the target property graph.
  // If this is a subquery, the graph reference is optional and may be
  // inferred from the context.
  optional ASTPathExpressionProto graph_reference = 2;
  // Graph matching operator. Can be an ASTGqlMatch or an
  // ASTGqlOperatorList. See (broken link):gql-graph-table for more details
  optional AnyASTGqlOperatorProto graph_op = 3;
  // The expression list with aliases to be projected to the outer
  // query. Exists only when `graph_op` is an ASTGqlMatch. See
  // (broken link):gql-graph-table for more details
  optional ASTSelectListProto graph_table_shape = 5;
  optional ASTAliasProto alias = 6;
}

// Represents a graph element label expression.
message AnyASTGraphLabelExpressionProto {
  oneof node {
    ASTGraphElementLabelProto ast_graph_element_label_node = 360;
    ASTGraphWildcardLabelProto ast_graph_wildcard_label_node = 361;
    ASTGraphLabelOperationProto ast_graph_label_operation_node = 362;
  }
}
message ASTGraphLabelExpressionProto {
  optional ASTNodeProto parent = 1;
  optional bool parenthesized = 2;
}

message ASTGraphElementLabelProto {
  optional ASTGraphLabelExpressionProto parent = 1;
  optional ASTIdentifierProto name = 2;
}

message ASTGraphWildcardLabelProto {
  optional ASTGraphLabelExpressionProto parent = 1;
}

message ASTGraphLabelOperationProto {
  optional ASTGraphLabelExpressionProto parent = 1;
  optional ASTGraphLabelOperationEnums.OperationType op_type = 2;
  repeated AnyASTGraphLabelExpressionProto inputs = 3;
}

// Filter label on a graph node or edge pattern. This node wraps the label
// expression filter just like ASTWhereClause wraps the scalar filter
// expression.
message ASTGraphLabelFilterProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTGraphLabelExpressionProto label_expression = 3;
}

// Binary expression which contains an element variable name `operand` and
// a `label_expression`.
// Note we do not use ASTBinaryExpression because we need to accommodate
// `label_expression` which is not an `expression`.
message ASTGraphIsLabeledPredicateProto {
  optional ASTExpressionProto parent = 1;
  // Signifies whether the predicate has a NOT.
  // Used for "IS NOT LABELED"
  optional bool is_not = 2;
  optional AnyASTExpressionProto operand = 3;
  optional AnyASTGraphLabelExpressionProto label_expression = 4;
}

// Filler of an element pattern which can contain the element variable name
// of this pattern and two element filters (label-based filter and where
// clause filter).
message ASTGraphElementPatternFillerProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto variable_name = 2;
  optional ASTGraphLabelFilterProto label_filter = 3;
  optional ASTWhereClauseProto where_clause = 4;
  optional ASTGraphPropertySpecificationProto property_specification = 5;
  optional ASTHintProto hint = 6;
  optional AnyASTExpressionProto edge_cost = 7;
}

// The property specification that contains a list of property name and value
// .
message ASTGraphPropertySpecificationProto {
  optional ASTNodeProto parent = 1;
  repeated ASTGraphPropertyNameAndValueProto property_name_and_value = 2;
}

// Property name and value pair.
message ASTGraphPropertyNameAndValueProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto property_name = 2;
  optional AnyASTExpressionProto value = 3;
}

// Common base class for ASTGraphElementPattern and ASTGraphPathPattern.
// Both are potentially quantified.
message AnyASTGraphPathBaseProto {
  oneof node {
    AnyASTGraphElementPatternProto ast_graph_element_pattern_node = 371;
    ASTGraphPathPatternProto ast_graph_path_pattern_node = 377;
  }
}
message ASTGraphPathBaseProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTQuantifierProto quantifier = 2;
}

// Represents one element pattern.
message AnyASTGraphElementPatternProto {
  oneof node {
    ASTGraphNodePatternProto ast_graph_node_pattern_node = 357;
    ASTGraphEdgePatternProto ast_graph_edge_pattern_node = 372;
  }
}
message ASTGraphElementPatternProto {
  optional ASTGraphPathBaseProto parent = 1;
  optional ASTGraphElementPatternFillerProto filler = 2;
}

// ASTGraphElementPattern that represents one node pattern.
message ASTGraphNodePatternProto {
  optional ASTGraphElementPatternProto parent = 1;
}

// ASTGraphLhsHint is used to represent a hint that occurs on a traversal
// from a node to an inbound edge.
message ASTGraphLhsHintProto {
  optional ASTNodeProto parent = 1;
  optional ASTHintProto hint = 2;
}

// ASTGraphRhsHint is used to represent a hint that occurs on a traversal
// from an outbound edge to a node.
message ASTGraphRhsHintProto {
  optional ASTNodeProto parent = 1;
  optional ASTHintProto hint = 2;
}

// Represents a path pattern search prefix which restricts the result from a
// graph pattern match by partitioning the resulting paths by their endpoints
// (the first and last vertices) and makes a selection of paths from each
// partition.
// path_count refers to the number of paths to select from each partition,
// if unspecified only one path is selected.
message ASTGraphPathSearchPrefixProto {
  optional ASTNodeProto parent = 1;
  optional ASTGraphPathSearchPrefixEnums.PathSearchPrefixType type = 2;
  optional ASTGraphPathSearchPrefixCountProto path_count = 3;
}

// Represents the number of paths to retain from each partition of path
// bindings containing the same head and tail.
message ASTGraphPathSearchPrefixCountProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto path_count = 2;
}

// ASTGraphElementPattern that represents one edge pattern.
message ASTGraphEdgePatternProto {
  optional ASTGraphElementPatternProto parent = 1;
  optional ASTGraphEdgePatternEnums.EdgeOrientation orientation = 2;
  optional ASTGraphLhsHintProto lhs_hint = 3;
  optional ASTGraphRhsHintProto rhs_hint = 4;
}

// Represents path mode.
message ASTGraphPathModeProto {
  optional ASTNodeProto parent = 1;
  optional ASTGraphPathModeEnums.PathMode path_mode = 2;
}

// Represents a path pattern that contains a list of element
// patterns or subpath patterns.
message ASTGraphPathPatternProto {
  optional ASTGraphPathBaseProto parent = 1;
  optional ASTHintProto hint = 2;
  optional ASTWhereClauseProto where_clause = 3;
  optional ASTGraphPathModeProto path_mode = 4;
  repeated AnyASTGraphPathBaseProto input_pattern_list = 5;
  optional bool parenthesized = 6;
  optional ASTGraphPathSearchPrefixProto search_prefix = 7;
  optional ASTIdentifierProto path_name = 8;
}

// Represents a generic graph operator in ZetaSQL graph query language.
message AnyASTGqlOperatorProto {
  oneof node {
    ASTGqlMatchProto ast_gql_match_node = 433;
    ASTGqlReturnProto ast_gql_return_node = 434;
    ASTGqlOperatorListProto ast_gql_operator_list_node = 436;
    ASTGqlLetProto ast_gql_let_node = 441;
    ASTGqlFilterProto ast_gql_filter_node = 444;
    ASTGqlOrderByAndPageProto ast_gql_order_by_and_page_node = 461;
    ASTGqlSetOperationProto ast_gql_set_operation_node = 472;
    ASTGqlWithProto ast_gql_with_node = 473;
    ASTGqlForProto ast_gql_for_node = 476;
    ASTGqlSampleProto ast_gql_sample_node = 507;
    AnyASTGqlCallBaseProto ast_gql_call_base_node = 523;
  }
}
message ASTGqlOperatorProto {
  optional ASTNodeProto parent = 1;
}

// Represents a MATCH operator in ZetaSQL graph query language,
// which simply contains <graph pattern>.
message ASTGqlMatchProto {
  optional ASTGqlOperatorProto parent = 1;
  optional ASTGraphPatternProto graph_pattern = 2;
  optional bool optional = 3;
  optional ASTHintProto hint = 4;
}

// Represents a RETURN operator in ZetaSQL graph query language.
// RETURN is represented with an ASTSelect with only the
// SELECT, DISTINCT, and (optionally) GROUP BY clause present.
// Using this representation rather than storing an ASTSelectList and
// ASTGroupBy makes sharing resolver code easier.
message ASTGqlReturnProto {
  optional ASTGqlOperatorProto parent = 1;
  optional ASTSelectProto select = 2;
  optional ASTGqlOrderByAndPageProto order_by_page = 3;
}

// Represents a WITH operator in ZetaSQL graph query language.
// WITH is represented with an ASTSelect with only the
// SELECT clause present.
message ASTGqlWithProto {
  optional ASTGqlOperatorProto parent = 1;
  optional ASTSelectProto select = 2;
}

// Represents a FOR operator in ZetaSQL graph query language.
message ASTGqlForProto {
  optional ASTGqlOperatorProto parent = 1;
  optional ASTIdentifierProto identifier = 2;
  optional AnyASTExpressionProto expression = 3;
  optional ASTWithOffsetProto with_offset = 4;
}

// Represents a GQL CALL operator.
// Note that this is different from the pipe Call.
message AnyASTGqlCallBaseProto {
  oneof node {
    ASTGqlNamedCallProto ast_gql_named_call_node = 524;
    ASTGqlInlineSubqueryCallProto ast_gql_inline_subquery_call_node = 526;
  }
}
message ASTGqlCallBaseProto {
  optional ASTGqlOperatorProto parent = 1;
  optional bool optional = 2;
  // Indicates whether this call partitions the input working table.
  //
  // When set, the `name_capture_list` defines the partitioning
  // columns. The target of this CALL operation (TVF or subquery) is
  // invoked for each partition. This is a FOR EACH PARTITION BY
  // operation (and if the list is empty, a simple TVF call).
  //
  // Otherwise, the target is invoked for each row in the input
  // (like LATERAL join). The `name_capture_list` contains the
  // columns exposed to the derived subquery/TVF (i.e., these are the
  // columns which can be referenced "laterally").
  //
  // Note that both cases can be viewed as similar, if we consider
  // that the "non-partitioning" case is still partitioning but by
  // a hidden row ID column which leads to each row being in its own
  // partition.
  optional bool is_partitioning = 3;
  // The list of columns exposed to the target TVF or subquery of
  // this CALL. If `is_partitioning` is set, these are the
  // partitioning columns. Otherwise, these are the columns which can
  // be referenced "laterally".
  optional ASTIdentifierListProto name_capture_list = 4;
}

// Represents a GQL CALL operator to a named TVF.
message ASTGqlNamedCallProto {
  optional ASTGqlCallBaseProto parent = 1;
  optional ASTTVFProto tvf_call = 2;
  // Represents the YIELD clause, if present.
  optional ASTYieldItemListProto yield_clause = 3;
}

// Represents the YIELD clause.
message ASTYieldItemListProto {
  optional ASTNodeProto parent = 1;
  // The list of YIELD items in the YIELD clause. The grammar
  // guarantees that this list is never empty.
  repeated ASTExpressionWithOptAliasProto yield_items = 2;
}

// Represents a GQL CALL operator to an inline subquery.
message ASTGqlInlineSubqueryCallProto {
  optional ASTGqlCallBaseProto parent = 1;
  optional ASTQueryProto subquery = 2;
}

// Represents a LET operator in ZetaSQL graph query language
message ASTGqlLetProto {
  optional ASTGqlOperatorProto parent = 1;
  optional ASTGqlLetVariableDefinitionListProto variable_definition_list = 2;
}

// Represents column definitions within a LET statement of a GQL query
message ASTGqlLetVariableDefinitionListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTGqlLetVariableDefinitionProto variable_definitions = 2;
}

// Represents one column definition within a LET statement of a GQL query
message ASTGqlLetVariableDefinitionProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto identifier = 2;
  optional AnyASTExpressionProto expression = 3;
}

// Represents a FILTER operator within ZetaSQL Graph query language.
message ASTGqlFilterProto {
  optional ASTGqlOperatorProto parent = 1;
  optional ASTWhereClauseProto condition = 2;
}

// Represents a linear graph query operator in
// ZetaSQL graph query language, which contains a vector of child
// graph query operators.
message ASTGqlOperatorListProto {
  optional ASTGqlOperatorProto parent = 1;
  repeated AnyASTGqlOperatorProto operators = 2;
}

// Represents a composite query statement, aka. set operation, in
// ZetaSQL graph query language. Each input is one linear graph query.
message ASTGqlSetOperationProto {
  optional ASTGqlOperatorProto parent = 1;
  optional ASTSetOperationMetadataListProto metadata = 2;
  repeated AnyASTGqlOperatorProto inputs = 3;
}

// Represents the LIMIT clause of a GQL '[<order by>] [<offset>] [<limit>]`
// linear query statement. It is a child of ASTGqlPage. Note: we cannot use
// an ASTLimitOffset node because its 'limit' field is required, while it can
// be optional in GQL linear queries. We also cannot have two
// consecutive OPTIONAL_EXPRESSION fields in ASTGqlPage.
message ASTGqlPageLimitProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto limit = 2;
}

// Represents the OFFSET clause of a GQL '[<order by>] [<offset>] [<limit>]`
// linear query statement. It is a child of ASTGqlPage. Note: we cannot use
// an ASTLimitOffset node because its 'limit' field is required, while it can
// be optional in GQL linear queries. We also cannot have two
// consecutive OPTIONAL_EXPRESSION fields in ASTGqlPage.
message ASTGqlPageOffsetProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto offset = 2;
}

// Groups together ASTGqlPageOffset and ASTGqlPageLimit nodes. Note: we
// cannot use an ASTLimitOffset node because its 'limit' field is required,
// while it can be optional in GQL linear queries. We also cannot have two
// consecutive OPTIONAL_EXPRESSION fields.
message ASTGqlPageProto {
  optional ASTNodeProto parent = 1;
  // The OFFSET value. Offset and limit are independent, and can be
  // present or not regardless of whether the other is present.
  optional ASTGqlPageOffsetProto offset = 2;
  // The LIMIT value. Offset and limit are independent, and can be
  // present or not regardless of whether the other is present.
  optional ASTGqlPageLimitProto limit = 3;
}

// Represents the three clauses of a GQL '[<order by>] [<offset>] [<limit>]`
// linear query statement.
message ASTGqlOrderByAndPageProto {
  optional ASTGqlOperatorProto parent = 1;
  optional ASTOrderByProto order_by = 2;
  optional ASTGqlPageProto page = 3;
}

// Represents a SAMPLE operator within ZetaSQL Graph query language.
message ASTGqlSampleProto {
  optional ASTGqlOperatorProto parent = 1;
  optional ASTSampleClauseProto sample = 2;
}

// Represents SELECT WITH clause.
message ASTSelectWithProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto identifier = 2;
  optional ASTOptionsListProto options = 3;
}

message ASTColumnWithOptionsProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentifierProto name = 2;
  optional ASTOptionsListProto options_list = 3;
}

message ASTColumnWithOptionsListProto {
  optional ASTNodeProto parent = 1;
  repeated ASTColumnWithOptionsProto column_with_options = 2;
}

// Represents the body of a DEFINE MACRO statement.
message ASTMacroBodyProto {
  optional ASTPrintableLeafProto parent = 1;
}

// Represents a DEFINE MACRO statement.
message ASTDefineMacroStatementProto {
  optional ASTStatementProto parent = 1;
  optional ASTIdentifierProto name = 2;
  optional ASTMacroBodyProto body = 3;
}

// This represents an UNDROP statement (broken link)
message ASTUndropStatementProto {
  optional ASTDdlStatementProto parent = 1;
  optional SchemaObjectKind schema_object_kind = 2;
  optional ASTPathExpressionProto name = 3;
  optional bool is_if_not_exists = 4;
  optional ASTForSystemTimeProto for_system_time = 5;
  optional ASTOptionsListProto options_list = 6;
}

message ASTIdentityColumnInfoProto {
  optional ASTNodeProto parent = 1;
  optional ASTIdentityColumnStartWithProto start_with_value = 2;
  optional ASTIdentityColumnIncrementByProto increment_by_value = 3;
  optional ASTIdentityColumnMaxValueProto max_value = 4;
  optional ASTIdentityColumnMinValueProto min_value = 5;
  optional bool cycling_enabled = 6;
}

message ASTIdentityColumnStartWithProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto value = 2;
}

message ASTIdentityColumnIncrementByProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto value = 2;
}

message ASTIdentityColumnMaxValueProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto value = 2;
}

message ASTIdentityColumnMinValueProto {
  optional ASTNodeProto parent = 1;
  optional AnyASTExpressionProto value = 2;
}

message ASTAliasedQueryModifiersProto {
  optional ASTNodeProto parent = 1;
  optional ASTRecursionDepthModifierProto recursion_depth_modifier = 2;
}

// This represents an integer or an unbounded integer.
// The semantic of unbounded integer depends on the context.
message ASTIntOrUnboundedProto {
  optional ASTExpressionProto parent = 1;
  optional AnyASTExpressionProto bound = 2;
}

message ASTRecursionDepthModifierProto {
  optional ASTNodeProto parent = 1;
  optional ASTAliasProto alias = 2;
  // lower bound is 0 when the node's `bound` field is unset.
  optional ASTIntOrUnboundedProto lower_bound = 3;
  // upper_bound is infinity when the node's `bound` field is unset.
  optional ASTIntOrUnboundedProto upper_bound = 4;
}

message ASTMapTypeProto {
  optional ASTTypeProto parent = 1;
  optional AnyASTTypeProto key_type = 2;
  optional AnyASTTypeProto value_type = 3;
  optional ASTTypeParameterListProto type_parameters = 4;
  optional ASTCollateProto collate = 5;
}

message ASTLockModeProto {
  optional ASTNodeProto parent = 1;
  // The lock strength. Never NULL.
  optional ASTLockModeEnums.LockStrengthSpec strength = 2;
}

// Represents a pipe RECURSIVE UNION operator ((broken link)):
// ```
// |> RECURSIVE [outer_mode] UNION {ALL | DISTINCT} [corresponding_spec]
//    [recursion_depth_clause]
//    {<subquery> | <subpipeline>}
//    [AS alias]
// ```
//
// It is semantically the same as the standard recursive queries using WITH
// RECURSIVE but the syntax is more intuitive.
//
// It supports subqueries or subpipelines as input.
// Exactly one of `input_subquery` and `input_subpipeline` will be set.
message ASTPipeRecursiveUnionProto {
  optional ASTPipeOperatorProto parent = 1;
  optional ASTSetOperationMetadataProto metadata = 2;
  // The optional recursion depth modifier for the recursive query.
  optional ASTRecursionDepthModifierProto recursion_depth_modifier = 3;
  // The input subpipeline for the recursive union operator. The
  // input table to the subpipeline is the output of the previous
  // iteration.
  //
  // Example:
  //
  // ```SQL
  // FROM KeyValue
  // |> RECURSIVE UNION ALL (
  //     |> SET value = value + 1
  //     |> WHERE key < 10
  //   )
  optional ASTSubpipelineProto input_subpipeline = 4;
  // The input subquery for the recursive union operator.
  //
  // Example:
  //
  // ```SQL
  // FROM KeyValue
  // |> RECURSIVE UNION ALL (
  //     SELECT key, value + 1 AS value
  //     FROM KeyValue
  //     WHERE key < 10
  //   )
  // ```
  optional AnyASTQueryExpressionProto input_subquery = 5;
  // The optional alias for the result of the recursive union. Note
  // it acts as both the input table to the next iteration, and the
  // output table of the recursive union. For example, in the
  // following query:
  //
  // ```SQL
  // FROM TreeNodes
  // |> RECURSIVE UNION ALL (
  //   |> JOIN TreeNodes AS child_node ON
  //       nodes.id = child_node.parent_id
  //   |> SELECT child_node.*
  // ) AS nodes;
  // ```
  //
  // The alias `nodes` is the output table of the recursive union,
  // and the input table to the next iteration.
  optional ASTAliasProto alias = 6;
}

// Represents a RUN statement.
//
// Syntax: RUN <child_script_path> [(<named_arguments>)]
//
// The RUN statement is used to execute statements in a separate script.
// The child script path maybe specified as a string literal or a path
// expression.
//
// Optional named arguments are supported using either `=>` or `=`.
//
// With path expression syntax, parentheses are required even if there are
// no arguments.
//
// Examples:
// ```
// -- Parentheses are optional when using string literal syntax.
// RUN "path/to/script.sql";
// RUN "path/to/script.sql"(foo => "bar");
// RUN "path/to/another_script.sql"();
// RUN my_catalog.my_script(foo => "bar");
//
// -- Parentheses are NOT optional when using path expression syntax.
// RUN my_catalog.my_script();
// ```
message ASTRunStatementProto {
  optional ASTStatementProto parent = 1;
  // The target script addressed using an ASTPathExpression.
  // Exactly one of `target_path` and `target_string` will be set.
  //
  // e.g. `RUN my_catalog.my_script();`
  optional ASTPathExpressionProto target_path_expression = 2;
  // The target script addressed by a ASTStringLiteral.
  // Exactly one of `target_path` and `target_string` will be set.
  //
  // e.g. `RUN "path/to/script.sql";`
  optional ASTStringLiteralProto target_string_literal = 3;
  // Represents named arguments supplied to the child script
  // for parameter substitution. Arguments are optional.
  //
  // Argument names are required to be valid identifiers, and
  // argument values are required to be string literals.
  //
  // Examples:
  // ```
  // RUN my_catalog.preamble();
  // RUN my_catalog.my_script(foo => "bar")
  // ```
  repeated ASTNamedArgumentProto arguments = 4;
}

// This represents a CREATE SEQUENCE statement, i.e.,
// CREATE [OR REPLACE] SEQUENCE
//   [IF NOT EXISTS] <name_path> OPTIONS (name=value, ...);
message ASTCreateSequenceStatementProto {
  optional ASTCreateStatementProto parent = 1;
  optional ASTPathExpressionProto name = 2;
  optional ASTOptionsListProto options_list = 3;
}

// This represents a ALTER SEQUENCE statement, i.e.,
// ALTER SEQUENCE <name_path> SET OPTIONS (name=value, ...);
message ASTAlterSequenceStatementProto {
  optional ASTAlterStatementBaseProto parent = 1;
}
// clang-format on